## Chapter 3

### 3.4 访问信息

#### 3.4.4

注意此处介绍的压栈和出栈的命令都是四字操作。

也就是说，不管你是多少字节的，都按照四字来存储的。~~这样也的确方便出栈，而不用管存储在内存里的数据大小；~~

### 3.7 过程

#### 3.7.1 运行时栈

> 当 x86-64 过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧(stack fram)。

~~也就是说整个函数包含的变量和参数个数要尽可能的少来减少内存调用。但查看编译，有时看到上来就将一个寄存器压入栈中，结束前再出栈，可能是非传递参数的寄存器之前已经有值了。~~

#### 3.7.2 转移控制

*以下结论是在 `-Og` 的情况得出的。*

运行时的寄存器状态完全由汇编/代码来控制，比如你需要将需要传递的参数自行按照顺序放入到 `%rdi`、`%rsi`、`%rdx` 的寄存器中，如果超过上线六个，怕是也是由代码事先准备好栈帧。

**栈顶是函数回调的地址，`%rsp+8` 是第 7 个参数，`%rsp+16` 是第 8 个参数，以此类推。**

~~我们再来看汇编代码为什么上来需要进行一次压栈操作。这种情况发生在：~~

- ~~一个变量由参数传递入函数中；~~
- ~~这个变量作为参数调用一次函数；~~
- ~~函数调用完后，这个参数还有用；~~

~~原因可能是：~~

- ~~代码需要一个寄存器例如 `%rbx`，但是不确定调用栈中是否使用；~~

- ~~**c 语言中函数中修改非引用参数时，不会影响到调用时的实参。**~~

  ~~`%rbx` 中保存一份（类似于本地/局部变量）。~~

实例代码有一个有趣的地方，一个参数不停地作为第一参数调用函数栈的过程中，代码只要将其放在寄存器 `%rdi` 上操作就可以了。如果在一次调用中作为了第二参数，那就会多一步 `mov` 的操作，将其移至 `%rsi` 中。不过前提是代码调用后面都不能有该参数/变量的其他引用/使用。**这里甚至还没有实参和形参的概念，没有作为函数参数还需要进行拷贝的行为。**

练习题的一次调用压栈 `%rsp` 减小了 8（个字节），这是因为一次压栈使用 `pushq` 默认顶格 8 个字节；

#### 3.7.3 数据传送

> 如果一个函数有大于 6 个整型参数，超出 6 个的部分就要通过栈来传递。
>
> 要把参数 1~6 复制到对应的寄存器，把参数 7~n 放到栈上，而参数 7 位于栈顶。
>
> 通过栈传递参数时，所有的数据大小都向 8 的倍数对齐。

需要注意的是，示例代码中 `a4` 是 1 个字节，但是从栈中提取的时候使用了 `movl` 实际上提取了 8 个字节（高位自动补 0）；

练习题的答案，第二种是交换两组变量顺序，但编译器一般按顺序编译；

另一种思路是 `v` 和 `b` 可以同时是有符号或者无符号整数，这在底层来看是没有差的，生成的汇编代码也是完全相同的；

 #### 3.7.4 栈上的局部存储

当栈中存储局部变量时，是可以紧凑存储的；

但是作为超过6个函数传参应该是必须占8个字节；

*有一点奇怪的地方就是，我在 `centos` 的虚拟机里编译器申请了40个字节，而例子只有32个字节；*

#### 3.7.5 寄存器中的局部存储空间

> 根据惯例，寄存器 `%rbx`、`%rbp` 和 `%r12` ~ `%r15` 被划分为被*调用者保存*寄存器。其余除 `%rsp` 都分类为*调用者保存*寄存器。
>
> 当过程 P 调用 过程 Q 时，过程 Q 保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后再返回前从栈中弹出旧值。
>
> 理解“调用者保存”这个名字：过程 P 调用过程 Q，Q 可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是 P （调用者）的责任。

示例代码中，对栈指针执行了一步额外的操作：

```assembly
subq $8, %rsp
addq $8, %rsp
```

看看后面会不会讲解。

### 3.8 数组分配和访问

#### 3.8.2 指针运算

> 最后一个例子表明可以计算同一个数据结构中的两个指针之差，结果的数据类型为 `long`，值等于两个地址之差除以该数据类型的大小。

例子中，整数索引是用 `long` 来存储的；

练习题答案地址计算使用 `leal` 应该错了吧；

#### 3.8.4

示例代码在计算行指针的时候，如果列和类型字节乘积恰好是 2 的指数的话，只需 `salq` 一条就能算完偏移量；

例如此处，`int` 占用 4 个字节，一行数组有 16 个元素，`i` 存储在 `%rdx` ，那么计算指向 `A[i]` 的行指针 `4 * 16 * i = 64 * i` 也就是一条汇编代码：

```assembly
salq $6, %rdx
```

所以在创建数组长度的时候可以考虑凑个整；

