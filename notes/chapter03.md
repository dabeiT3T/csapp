## Chapter 3

### 3.4 访问信息

#### 3.4.2

> x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。
>
> 唯一的例外是 `movl` 指令以寄存器作为目的时，它会把该寄存器的高位 4 字节设置为 0。造成这个例外的原因是 x86-64 采用的惯例，即如何为寄存器生成 32 位值的指令都会把该寄存器的高位部分置成 0。

#### 3.4.4

注意此处介绍的压栈和出栈的命令都是四字操作。

也就是说，不管你是多少字节的，都按照四字来存储的。~~这样也的确方便出栈，而不用管存储在内存里的数据大小；~~

### 3.6 控制

#### 3.6.5 用条件控制来实现条件分支

```c
    t = test_expr;
    if (!t)
        goto false;
    // then-statement
    goto done;
false:
    // else-statement
done:
```

条件求返是因为如果没有 else 分支就可以直接简化成

```c
    t = test_expr;
    if (!t)
        goto done;
    // then-statement
done:
```

#### 3.6.6 用条件传送来实现条件分支

> 实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效。
>
> 一种替代的策略时使用数据的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。只有在一些受限制的情况中，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理器的性能特性。
>
> 处理器通过使用流水线来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器）。这种方法通过重叠连续指令的步骤来获得高性能，例如，在取一条指令的同时，执行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行的指令序列，这样才能保持流水线中充满了待执行的指令。当机器遇到条件跳转（分支）时，只有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠（现代微处理器设计试图达到 90% 以上的成功率），指令流水线中就会充满着指令。另一方面，错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令已做的工作，然后再开始用从正确位置处起始的指令去填充流水线。这样一个错误预测会招致很严重的惩罚，浪费大约 15~30 个时钟周期，导致程序性能严重下降。

#### 3.6.7 循环

##### do-while

```c
loop:
    // body-statement
    t = test_expr;
    if (t)
        goto loop;
```

##### while

> 第一种翻译方法，我们称之为跳转到中间 (jump to middle)，他执行一个无条件跳转跳到循环结尾处的测试，以此来执行初始的测试。

```c
    goto test;
loop:
    //body-statement
test:
    t = test_expr;
    if (t)
        goto loop;
```

> 第二种翻译方法，我们称之为 guarded-do，首先用条件分支，如果初始条件不成立就跳过循环，把代码转换为 do-while 循环。当使用较高优化等级编译时，例如使用命令行选项 `-O1`，GCC 会采用这种策略。

```c
t = test_expr;
if (!t)
    goto done;
loop:
    // body-statement
    t = test_expr;
    if (t)
        goto loop;
done:
```

##### for

> GCC 为 for 循环产生的代码是 while 循环的两种翻译之一，这取决于优化的等级。

#### 3.8 switch 语句

> 通过使用跳转表 (jump table) 这种数据结构使得实现更加高效。跳转表是一个数组，表项 i 是一个代码段的地址，这个代码段实现当开关索引值等于 i 时程序应该采取的动作。
>
> 当开关情况数量比较多（例如 4 个以上），并且值的范围跨度比较小时，就会使用跳转表。

简单来说类似哈希表，例如针对值 100、102-104 和 106 的情况。将他们减去 100 就获得了一个长度为 6 的哈希表；对匹配参数转化为无符号减去 100（小于则正溢出），如果值在索引范围内则跳转数组中代码块的地址。

### 3.7 过程

#### 3.7.1 运行时栈

> 当 x86-64 过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧(stack fram)。

~~也就是说整个函数包含的变量和参数个数要尽可能的少来减少内存调用。但查看编译，有时看到上来就将一个寄存器压入栈中，结束前再出栈，可能是非传递参数的寄存器之前已经有值了。~~

#### 3.7.2 转移控制

*以下结论是在 `-Og` 的情况得出的。*

运行时的寄存器状态完全由汇编/代码来控制，比如你需要将需要传递的参数自行按照顺序放入到 `%rdi`、`%rsi`、`%rdx` 的寄存器中，如果超过上线六个，怕是也是由代码事先准备好栈帧。

**栈顶是函数回调的地址，`%rsp+8` 是第 7 个参数，`%rsp+16` 是第 8 个参数，以此类推。**

~~我们再来看汇编代码为什么上来需要进行一次压栈操作。这种情况发生在：~~

- ~~一个变量由参数传递入函数中；~~
- ~~这个变量作为参数调用一次函数；~~
- ~~函数调用完后，这个参数还有用；~~

~~原因可能是：~~

- ~~代码需要一个寄存器例如 `%rbx`，但是不确定调用栈中是否使用；~~

- ~~**c 语言中函数中修改非引用参数时，不会影响到调用时的实参。**~~

  ~~`%rbx` 中保存一份（类似于本地/局部变量）。~~

实例代码有一个有趣的地方，一个参数不停地作为第一参数调用函数栈的过程中，代码只要将其放在寄存器 `%rdi` 上操作就可以了。如果在一次调用中作为了第二参数，那就会多一步 `mov` 的操作，将其移至 `%rsi` 中。不过前提是代码调用后面都不能有该参数/变量的其他引用/使用。**这里甚至还没有实参和形参的概念，没有作为函数参数还需要进行拷贝的行为。**

练习题的一次调用压栈 `%rsp` 减小了 8（个字节），这是因为一次压栈使用 `pushq` 默认顶格 8 个字节；

#### 3.7.3 数据传送

> 如果一个函数有大于 6 个整型参数，超出 6 个的部分就要通过栈来传递。
>
> 要把参数 1~6 复制到对应的寄存器，把参数 7~n 放到栈上，而参数 7 位于栈顶。
>
> 通过栈传递参数时，所有的数据大小都向 8 的倍数对齐。

需要注意的是，示例代码中 `a4` 是 1 个字节，但是从栈中提取的时候使用了 `movl` 实际上提取了 8 个字节（高位自动补 0）；

练习题的答案，第二种是交换两组变量顺序，但编译器一般按顺序编译；

另一种思路是 `v` 和 `b` 可以同时是有符号或者无符号整数，这在底层来看是没有差的，生成的汇编代码也是完全相同的；

 #### 3.7.4 栈上的局部存储

当栈中存储局部变量时，是可以紧凑存储的；

但是作为超过6个函数传参应该是必须占 8 个字节；

~~*有一点奇怪的地方就是，我在 `centos` 的虚拟机里编译器申请了 40 个字节，而例子只有 32 个字节；*~~可能的原因有：

1. 的确编译器会留有余地，避免缓冲区溢出；
2. 编译器为了数据对齐；

#### 3.7.5 寄存器中的局部存储空间

> 根据惯例，寄存器 `%rbx`、`%rbp` 和 `%r12` ~ `%r15` 被划分为被*调用者保存*寄存器。其余除 `%rsp` 都分类为*调用者保存*寄存器。
>
> 当过程 P 调用 过程 Q 时，过程 Q 保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后再返回前从栈中弹出旧值。
>
> 理解“调用者保存”这个名字：过程 P 调用过程 Q，Q 可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是 P （调用者）的责任。

示例代码中，对栈指针执行了一步额外的操作：

```assembly
subq $8, %rsp
addq $8, %rsp
```

~~看看后面会不会讲解。~~

### 3.8 数组分配和访问

#### 3.8.2 指针运算

> 最后一个例子表明可以计算同一个数据结构中的两个指针之差，结果的数据类型为 `long`，值等于两个地址之差除以该数据类型的大小。

例子中，整数索引是用 `long` 来存储的；

练习题答案地址计算使用 `leal` 应该错了吧；

#### 3.8.4 定长数组

示例代码在计算行指针的时候，如果列和类型字节乘积恰好是 2 的指数的话，只需 `salq` 一条就能算完偏移量；

例如此处，`int` 占用 4 个字节，一行数组有 16 个元素，`i` 存储在 `%rdx` ，那么计算指向 `A[i]` 的行指针 `4 * 16 * i = 64 * i` 也就是一条汇编代码：

```assembly
salq $6, %rdx
```

所以在创建数组长度的时候可以考虑凑个整；

#### 3.8.5 变长数组

> GCC 能够识别出程序访问多维数组的元素的步长。然后生成的代码会避免直接应用等式（3.1）会导致的乘法。这些优化都能显著提高程序的性能。

编译器尽量不使用乘法来计算例如遍历数组的列，使用加法的方法计算出地址；

### 3.9 异质的数据结构

#### 3.9.1 结构

> 结构的各个字段选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息。

类似于数组寻址，结构也会按照类型大小自动字段偏移量；

#### 3.9.2 联合

> 当用联合来将各种不同大小的数据类型整合到一起试，字节顺序问题就变得很重要了。

练习题通过 `GCC` 进行对比：

1. up->t1.v (short*)

   ```assembly
   movzwl 8(%rdi), %eax
   movw %ax, ($rsi)
   ```

   编译器将高位置为了 0；

2. &up->t1.w (char **)

   ```assembly
   addq $10, %rdi
   movq %rdi, (%rsi)
   ```

   注意 `dest` 指向的内存中存的是一个地址；

   计算地址其实还可以用 `leaq 10(%rdi), %rdi` 的方式，可能跟命令长度有关；

3. up->t2.a (int **)

   ```assembly
   movq %rdi, (%rsi)
   ```

   同样 `dest` 指向的内存中存的是一个地址；练习题答案只修改了 `%rsi` 寄存器里的地址，这样影响不到实参的值，肯定是不对的；

4. up->t2.a[up->t1.u] (int *)

   **注意数据传送指令不可以源和目标操作数同为内存地址；**

5. *up->t2.p (char *)

   ```assembly
   movq 8(%rdi), %rax
   movzbl (%rax), %eax
   mov %al, (%rsi)
   ```

   同上；

#### 3.9.3 数据对齐

> 对齐原则是任何 K 字节的基本对象的地址必须是 K 的倍数。

对于例如：

```c
struct S1 {
    int i;
    char c;
    int j;
};
```

的结构，因为 `j` 要想向 4 字节对齐，所以 `c` 后会插入一个 3 字节间隙；

自然会想到如果将 `i` 和 `j` 排列在一起可以顺利地使两者都对 4 字节对齐；但是如果：

```c
struct S2 {
    int i;
    int j;
    char c;
} d[4];
```

就会出现对不齐的情况，书中实例是在每个元组后浪费 3 个字节的方式补齐；

通过课后练习得出：

- 结构中最大原子变量占用 K 个字节；

- 结构的起始（作为结构元素也是）位置对齐 K 字节；

- 结构总大小对齐 K 字节，以便生成例如数组、作为结构元素的内存结构；

- > 当所有的数据元素的长度都是 2 的幂时，一种行之有效的策略是按照大小的降序排列结构的元素。

  可以最小化浪费的空间；

> 对于大多数 x86-64 指令来说，保持数据对齐能够提高效率，但是它不会影响程序的行为。另一方面，如果数据没有对齐，某些型号的处理器对于有些实现多媒体操作的 SSE 指令，就无法正确执行。这些指令对 16 字节数据块进行操作，在 SSE 单元和内存之间传送数据的指令要求内存地址必须是 16 的倍数。
>
> 因此，任何针对 x86-64 处理器的编译器和运行时系统都必须保证分配用来保存可能会被 SSE 寄存器读或写的数据结构的内存，都必须满足 16 字节对齐。这个要求有两个后果：
>
> - 任何内存分配函数（alloca、malloc、calloc 或 realloc）生成的块的起始地址都必须是 16 的倍数。
> - 大多数函数的栈帧的边界都必须是 16 字节的倍数。（这个要求有一些例外。）

### 3.10 在机器级程序中将控制与数据结合起来

> 首先，深入审视一下指针，它是 C 编程语言中最重要的概念之一。

#### 3.10.1 理解指针

> 特殊的 `void *` 类型代表通用指针。比如说，malloc 函数返回一个通用指针，然后通过显式强制类型转换或者赋值操作那样的隐式强制类型转换，将它转换成一个有类型的指针。
>
> - 指针也可以指向函数。
>
>   ```c
>   int fun(int x, int *p);
>   int (*fp)(int, int *);
>   fp = fun;
>   int y = 1;
>   int result = fp(3, &y);
>   ```
>
>   函数指针的值是该函数机器代码表示中第一条指令的地址。

#### 3.10.2 应用：使用 GDB 调试器

> GNU 的调试器 GDB 提供了许多有用的特性，支持机器级程序的运行时评估和分析。有了 GDB，可以观察正在运行的程序，同时又对程序的执行有相当的控制，这使得研究程序的行为变为可能。
>
> 运行 OBJ-DUMP 来获得程序的反汇编版本，是很有好处的。
>
> 相对于使用命令行接口来访问 GDB，许多程序员更愿意使用 DDD，它是 GDB 的一个扩展，提供了图形用户界面。

#### 3.10.3 内存越界引用的缓冲区溢出

> C 对于数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存在寄存器和返回地址）都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。
>
> 一种特别常见的状态破坏成为缓冲区溢出（buffer overflow）。通常，在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。
>
> 缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些执行代码的字节编码，称为攻击代码（exploit code），另外，还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，执行 `ret` 指令的效果就是跳转到攻击代码。
>
> 在一种攻击形式中，攻击代码会使用系统调用启动一个 shell 程序，给攻击者提供一组操作系统函数。在另一种形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行 `ret` 指令，（表面上）正常返回到调用者。

#### 3.10.4 对抗缓冲区溢出攻击

##### 1. 栈随机化

> 为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。
>
> 以传染病来打个比方，许多系统都容易受到同一种病毒的攻击，这种现象被称作安全单一化（security monoculture）。
>
> 栈随机化的思想使得栈的位置在程序每次运行时都有变化。实现的方式时：程序开始时，在栈上分配一段 0~n 字节的随机大小的空间。
>
> 在 Linux 系统中，栈随机化已经变成了标准行为。他是更大的一类技术中的一种，这类技术称为地址空间布局随机化（Address-Space Layout Randomization），或者简称 ASLR。采用 ASLR，每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域。

空操作雪橇（nop sled）的枚举次数计算方式是：

- 一个 `nop` 操作命令占用 1 个字节；

- 例如需要破解 n=2^23 的随机化，使用 256 字节的 nop sled；

  每次尝试，一个 256 字节的空操作 sled 会覆盖 2^8 个地址；因此一共需要枚举 (2^23)/(2^8)=2^15 个起始地址；

##### 2. 栈破坏检测

> 最近的 GCC 版本在产生的代码中加入了一种栈保护着（stack protector）机制，来检测缓冲区越界。其思想是在栈帧任何局部缓冲区与栈状态之间存储一个特殊的金丝雀（canary）值。这个金丝雀的值，也称为哨兵值（guard value），是在程序每次运行时随机产生的，因此，攻击者没有简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。如果是的，那么程序异常中止。
>
> 最近的 GCC 版本会试着确定一个函数是否容易遭受栈溢出攻击，并且自动插入这种溢出检测。使用命令行选项 `-fno-stack-protector` 来组织 GCC 产生这种代码。
>
> 它只会带来很小的性能损失，**特别是因为 GCC 只在函数中有局部 char 类型缓冲区的时候才插入这样的代码。**

##### 3. 限制可执行代码区域

> 最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。在典型的程序中，只有保存编译器生成的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。
>
> 有些类型的程序要求动态产生和执行代码的能力。例如，“即时（just-in-time）”编译技术为解释语言（例如 Java）编写的程序动态地产生代码，以提高执行性能。是否能够将可执行代码限制在由编译器在创建程序时产生地那个部分中，取决于语言和操作系统。

