## Chapter 3

### 3.2 程序编码

#### 3.2.3 关于格式的注解

> 虽然 C 编译器再把程序中表达的计算转换到机器代码方面表现出色，但是仍然有一些机器特性是 C 程序访问不到的。例如，每次 x86-64 处理器执行算数或逻辑运算时，如果得到的运算结果的低 8 位中有偶数个 1，那么就会把一个名为 PF 的 1 位条件码（condition code）标志设置为 1，否则就设置为 0。即使作为每次算数或逻辑运算的一部分，硬件都完成了这项计算，而 C 程序却无法知道 PF 条件码标志的值。在程序中插入几条汇编代码指令就能很容易地完成这项任务。
>
> 在 C 程序中插入汇编代码有两种方法。第一种是，我们可以编写完整地函数，放进一个独立地汇编代码文件中，让汇编器和链接器把它和用 C 语言书写地代码合并起来。第二种方法是，我们可以使用 GCC 地内联汇编（inline assembly）特性，用 `asm` 伪指令可以在 C 程序中包含简短地汇编代码。这种方法的好处是减少了与及其相关地代码量。

```c
int foo()
{
    __asm__(
        "movl $0, %eax\n\t"
    );
    // gcc generate codes `ret` by default for this function has a return type `int`
}
```

### 3.4 访问信息

#### 3.4.2

> x86-64 加了一条限制，传送指令的两个操作数不能都指向内存位置。
>
> 唯一的例外是 `movl` 指令以寄存器作为目的时，它会把该寄存器的高位 4 字节设置为 0。造成这个例外的原因是 x86-64 采用的惯例，即如何为寄存器生成 32 位值的指令都会把该寄存器的高位部分置成 0。

#### 3.4.4

注意此处介绍的压栈和出栈的命令都是四字操作。

也就是说，不管你是多少字节的，都按照四字来存储的。~~这样也的确方便出栈，而不用管存储在内存里的数据大小；~~

### 3.5 算数和逻辑操作

#### 3.5.5 特殊的算术操作

> x86-64 指令集对 128 位（16 字节）数的操作提供有限的支持。
>
> 一个是无符号数乘法（mulq），而另一个是补码乘法（imulq）。这两条指令都要求一个参数必须在寄存器 `%rax` 中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器 `%rdx`（高 64 位）和 `%rax` （低 64 位）中。
>
> 前面的算术运算表没有列出除法或取模操作。这些操作是由单操作数除法指令来提供的，类似于单操作数乘法指令。有符号除法指令 idivl 将寄存器 `%rdx`（高 64 位）和 `%rax`（低 64 位）中的 128 位数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器 `%rax` 中，将余数存储在寄存器 `%rdx` 中。
>
> 对于大多数 64 位除法应用来说，除数也常常是一个 64 位的值。这个值应该存放在 `%rax` 中，`%rdx` 的位应该设置位全 0（无符号运算）或者 `%rax` 的符号位（有符号运算）。后面这个操作可以用指令 cqto 来完成。这条指令不需要操作数——它隐含读出 `%rax` 的符号位，并将它复制到 `%rdx` 的所有位。

### 3.6 控制

#### 3.6.5 用条件控制来实现条件分支

```c
    t = test_expr;
    if (!t)
        goto false;
    // then-statement
    goto done;
false:
    // else-statement
done:
```

条件求返是因为如果没有 else 分支就可以直接简化成

```c
    t = test_expr;
    if (!t)
        goto done;
    // then-statement
done:
```

#### 3.6.6 用条件传送来实现条件分支

> 实现条件操作的传统方法是通过使用控制的条件转移。当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效。
>
> 一种替代的策略时使用数据的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。只有在一些受限制的情况中，这种策略才可行，但是如果可行，就可以用一条简单的条件传送指令来实现它，条件传送指令更符合现代处理器的性能特性。
>
> 处理器通过使用流水线来获得高性能，在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一小部分（例如，从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据，以及更新程序计数器）。这种方法通过重叠连续指令的步骤来获得高性能，例如，在取一条指令的同时，执行它前面一条指令的算术运算。要做到这一点，要求能够事先确定要执行的指令序列，这样才能保持流水线中充满了待执行的指令。当机器遇到条件跳转（分支）时，只有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠（现代微处理器设计试图达到 90% 以上的成功率），指令流水线中就会充满着指令。另一方面，错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令已做的工作，然后再开始用从正确位置处起始的指令去填充流水线。这样一个错误预测会招致很严重的惩罚，浪费大约 15~30 个时钟周期，导致程序性能严重下降。

#### 3.6.7 循环

##### do-while

```c
loop:
    // body-statement
    t = test_expr;
    if (t)
        goto loop;
```

##### while

> 第一种翻译方法，我们称之为跳转到中间 (jump to middle)，他执行一个无条件跳转跳到循环结尾处的测试，以此来执行初始的测试。

```c
    goto test;
loop:
    //body-statement
test:
    t = test_expr;
    if (t)
        goto loop;
```

> 第二种翻译方法，我们称之为 guarded-do，首先用条件分支，如果初始条件不成立就跳过循环，把代码转换为 do-while 循环。当使用较高优化等级编译时，例如使用命令行选项 `-O1`，GCC 会采用这种策略。

```c
t = test_expr;
if (!t)
    goto done;
loop:
    // body-statement
    t = test_expr;
    if (t)
        goto loop;
done:
```

##### for

> GCC 为 for 循环产生的代码是 while 循环的两种翻译之一，这取决于优化的等级。

#### 3.8 switch 语句

> 通过使用跳转表 (jump table) 这种数据结构使得实现更加高效。跳转表是一个数组，表项 i 是一个代码段的地址，这个代码段实现当开关索引值等于 i 时程序应该采取的动作。
>
> 当开关情况数量比较多（例如 4 个以上），并且值的范围跨度比较小时，就会使用跳转表。

简单来说类似哈希表，例如针对值 100、102-104 和 106 的情况。将他们减去 100 就获得了一个长度为 6 的哈希表；对匹配参数转化为无符号减去 100（小于则正溢出），如果值在索引范围内则跳转数组中代码块的地址。

### 3.7 过程

#### 3.7.1 运行时栈

> 当 x86-64 过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个部分称为过程的栈帧(stack fram)。

~~也就是说整个函数包含的变量和参数个数要尽可能的少来减少内存调用。但查看编译，有时看到上来就将一个寄存器压入栈中，结束前再出栈，可能是非传递参数的寄存器之前已经有值了。~~

#### 3.7.2 转移控制

> 在 x86-64 机器中，这个信息使用指令 `call Q` 调用过程 Q 来记录的。该指令会把地址 A 压入栈中，并将 PC 设置为 Q 的起始地址。压入的地址 A 被称为返回地址，是紧跟在 `call` 指令后面的那条指令的地址。对应的指令 `ret` 会从栈中弹出地址 A，并把 PC 设置为 A。

*以下结论是在 `-Og` 的情况得出的。*

运行时的寄存器状态完全由汇编/代码来控制，比如你需要将需要传递的参数自行按照顺序放入到 `%rdi`、`%rsi`、`%rdx` 的寄存器中，如果超过上限 6 个，怕是也是由代码事先准备好栈帧。

**前 6 个分别是 `%rdi`、`%rsi`、`%rdx`、`%rcx`、`%r8`、`%r9`；**

**栈顶是函数回调的地址，`%rsp+8` 是第 7 个参数，`%rsp+16` 是第 8 个参数，以此类推。**

~~我们再来看汇编代码为什么上来需要进行一次压栈操作。这种情况发生在：~~

- ~~一个变量由参数传递入函数中；~~
- ~~这个变量作为参数调用一次函数；~~
- ~~函数调用完后，这个参数还有用；~~

~~原因可能是：~~

- ~~代码需要一个寄存器例如 `%rbx`，但是不确定调用栈中是否使用；~~

- ~~**c 语言中函数中修改非引用参数时，不会影响到调用时的实参。**~~

  ~~`%rbx` 中保存一份（类似于本地/局部变量）。~~

实例代码有一个有趣的地方，一个参数不停地作为第一参数调用函数栈的过程中，代码只要将其放在寄存器 `%rdi` 上操作就可以了。如果在一次调用中作为了第二参数，那就会多一步 `mov` 的操作，将其移至 `%rsi` 中。不过前提是代码调用后面都不能有该参数/变量的其他引用/使用。**这里甚至还没有实参和形参的概念，没有作为函数参数还需要进行拷贝的行为。**

练习题的一次调用压栈 `%rsp` 减小了 8（个字节），这是因为一次压栈使用 `pushq` 默认顶格 8 个字节；

#### 3.7.3 数据传送

> 如果一个函数有大于 6 个整型参数，超出 6 个的部分就要通过栈来传递。
>
> 要把参数 1~6 复制到对应的寄存器，把参数 7~n 放到栈上，而参数 7 位于栈顶。
>
> 通过栈传递参数时，所有的数据大小都向 8 的倍数对齐。

需要注意的是，示例代码中 `a4` 是 1 个字节，但是从栈中提取的时候使用了 `movl` 实际上提取了 8 个字节（高位自动补 0）；

练习题的答案，第二种是交换两组变量顺序，但编译器一般按顺序编译；

另一种思路是 `v` 和 `b` 可以同时是有符号或者无符号整数，这在底层来看是没有差的，生成的汇编代码也是完全相同的；

 #### 3.7.4 栈上的局部存储

当栈中存储局部变量时，是可以紧凑存储的；**但是申请的时候得考虑到对齐的问题；**

但是作为超过6个函数传参应该是必须占 8 个字节；

~~*有一点奇怪的地方就是，我在 `centos` 的虚拟机里编译器申请了 40 个字节，而例子只有 32 个字节；*~~可能的原因有：

1. 的确编译器会留有余地，避免缓冲区溢出；
2. 编译器为了数据对齐；

#### 3.7.5 寄存器中的局部存储空间

> 根据惯例，寄存器 `%rbx`、`%rbp` 和 `%r12` ~ `%r15` 被划分为被*调用者保存*寄存器。其余除 `%rsp` 都分类为*调用者保存*寄存器。
>
> 当过程 P 调用 过程 Q 时，过程 Q 保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后再返回前从栈中弹出旧值。
>
> 理解“调用者保存”这个名字：过程 P 调用过程 Q，Q 可以随意修改这个寄存器，所以在调用之前首先保存好这个数据是 P （调用者）的责任。

示例代码中，对栈指针执行了一步额外的操作：

```assembly
subq $8, %rsp
addq $8, %rsp
```

~~看看后面会不会讲解。~~

### 3.8 数组分配和访问

#### 3.8.2 指针运算

> 最后一个例子表明可以计算同一个数据结构中的两个指针之差，结果的数据类型为 `long`，值等于两个地址之差除以该数据类型的大小。

例子中，整数索引是用 `long` 来存储的；

练习题答案地址计算使用 `leal` 应该错了吧；

#### 3.8.4 定长数组

示例代码在计算行指针的时候，如果列和类型字节乘积恰好是 2 的指数的话，只需 `salq` 一条就能算完偏移量；

例如此处，`int` 占用 4 个字节，一行数组有 16 个元素，`i` 存储在 `%rdx` ，那么计算指向 `A[i]` 的行指针 `4 * 16 * i = 64 * i` 也就是一条汇编代码：

```assembly
salq $6, %rdx
```

所以在创建数组长度的时候可以考虑凑个整；

#### 3.8.5 变长数组

> GCC 能够识别出程序访问多维数组的元素的步长。然后生成的代码会避免直接应用等式（3.1）会导致的乘法。这些优化都能显著提高程序的性能。

编译器尽量不使用乘法来计算例如遍历数组的列，使用加法的方法计算出地址；

### 3.9 异质的数据结构

#### 3.9.1 结构

> 结构的各个字段选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息。

类似于数组寻址，结构也会按照类型大小自动字段偏移量；

#### 3.9.2 联合

> 当用联合来将各种不同大小的数据类型整合到一起试，字节顺序问题就变得很重要了。

练习题通过 `GCC` 进行对比：

1. up->t1.v (short*)

   ```assembly
   movzwl 8(%rdi), %eax
   movw %ax, ($rsi)
   ```

   编译器将高位置为了 0；

2. &up->t1.w (char **)

   ```assembly
   addq $10, %rdi
   movq %rdi, (%rsi)
   ```

   注意 `dest` 指向的内存中存的是一个地址；

   计算地址其实还可以用 `leaq 10(%rdi), %rdi` 的方式，可能跟命令长度有关；

3. up->t2.a (int **)

   ```assembly
   movq %rdi, (%rsi)
   ```

   同样 `dest` 指向的内存中存的是一个地址；练习题答案只修改了 `%rsi` 寄存器里的地址，这样影响不到实参的值，肯定是不对的；

4. up->t2.a[up->t1.u] (int *)

   **注意数据传送指令不可以源和目标操作数同为内存地址；**

5. *up->t2.p (char *)

   ```assembly
   movq 8(%rdi), %rax
   movzbl (%rax), %eax
   mov %al, (%rsi)
   ```

   同上；

#### 3.9.3 数据对齐

> 对齐原则是任何 K 字节的基本对象的地址必须是 K 的倍数。

对于例如：

```c
struct S1 {
    int i;
    char c;
    int j;
};
```

的结构，因为 `j` 要想向 4 字节对齐，所以 `c` 后会插入一个 3 字节间隙；

自然会想到如果将 `i` 和 `j` 排列在一起可以顺利地使两者都对 4 字节对齐；但是如果：

```c
struct S2 {
    int i;
    int j;
    char c;
} d[4];
```

就会出现对不齐的情况，书中实例是在每个元组后浪费 3 个字节的方式补齐；

通过课后练习得出：

- 结构中最大原子变量占用 K 个字节；

- 结构的起始（作为结构元素也是）位置对齐 K 字节；

- 结构总大小对齐 K 字节，以便生成例如数组、作为结构元素的内存结构；

- > 当所有的数据元素的长度都是 2 的幂时，一种行之有效的策略是按照大小的降序排列结构的元素。

  可以最小化浪费的空间；

> 对于大多数 x86-64 指令来说，保持数据对齐能够提高效率，但是它不会影响程序的行为。另一方面，如果数据没有对齐，某些型号的处理器对于有些实现多媒体操作的 SSE 指令，就无法正确执行。这些指令对 16 字节数据块进行操作，在 SSE 单元和内存之间传送数据的指令要求内存地址必须是 16 的倍数。
>
> 因此，任何针对 x86-64 处理器的编译器和运行时系统都必须保证分配用来保存可能会被 SSE 寄存器读或写的数据结构的内存，都必须满足 16 字节对齐。这个要求有两个后果：
>
> - 任何内存分配函数（alloca、malloc、calloc 或 realloc）生成的块的起始地址都必须是 16 的倍数。
> - 大多数函数的栈帧的边界都必须是 16 字节的倍数。（这个要求有一些例外。）

堆栈的默认对齐方式，在 `windows` 中：

> 堆栈将始终保持为 16 字节对齐，除非是在 prolog 中（例如，压入返回地址之后），以及除非在某类帧函数的函数类型中指明。[^3]

`gcc` 中：

> `-mpreferred-stack-boundary`=num
>
> Attempt to keep the stack boundary aligned to a 2 raised to num byte boundary. If `-mpreferred-stack-boundary` is not specified, the default is 4 (16 bytes or 128 bits).[^4]

### 3.10 在机器级程序中将控制与数据结合起来

> 首先，深入审视一下指针，它是 C 编程语言中最重要的概念之一。

#### 3.10.1 理解指针

> 特殊的 `void *` 类型代表通用指针。比如说，malloc 函数返回一个通用指针，然后通过显式强制类型转换或者赋值操作那样的隐式强制类型转换，将它转换成一个有类型的指针。
>
> - 指针也可以指向函数。
>
>   ```c
>   int fun(int x, int *p);
>   int (*fp)(int, int *);
>   fp = fun;
>   int y = 1;
>   int result = fp(3, &y);
>   ```
>
>   函数指针的值是该函数机器代码表示中第一条指令的地址。

#### 3.10.2 应用：使用 GDB 调试器

> GNU 的调试器 GDB 提供了许多有用的特性，支持机器级程序的运行时评估和分析。有了 GDB，可以观察正在运行的程序，同时又对程序的执行有相当的控制，这使得研究程序的行为变为可能。
>
> 运行 OBJ-DUMP 来获得程序的反汇编版本，是很有好处的。
>
> 相对于使用命令行接口来访问 GDB，许多程序员更愿意使用 DDD，它是 GDB 的一个扩展，提供了图形用户界面。

#### 3.10.3 内存越界引用的缓冲区溢出

> C 对于数组引用不进行任何边界检查，而且局部变量和状态信息（例如保存在寄存器和返回地址）都存放在栈中。这两种情况结合到一起就能导致严重的程序错误，对越界的数组元素的写操作会破坏存储在栈中的状态信息。
>
> 一种特别常见的状态破坏成为缓冲区溢出（buffer overflow）。通常，在栈中分配某个字符数组来保存一个字符串，但是字符串的长度超出了为数组分配的空间。
>
> 缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种常见的通过计算机网络攻击系统安全的方法。通常，输入给程序一个字符串，这个字符串包含一些执行代码的字节编码，称为攻击代码（exploit code），另外，还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，执行 `ret` 指令的效果就是跳转到攻击代码。
>
> 在一种攻击形式中，攻击代码会使用系统调用启动一个 shell 程序，给攻击者提供一组操作系统函数。在另一种形式中，攻击代码会执行一些未授权的任务，修复对栈的破坏，然后第二次执行 `ret` 指令，（表面上）正常返回到调用者。

#### 3.10.4 对抗缓冲区溢出攻击

##### 1. 栈随机化

> 为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。
>
> 以传染病来打个比方，许多系统都容易受到同一种病毒的攻击，这种现象被称作安全单一化（security monoculture）。
>
> 栈随机化的思想使得栈的位置在程序每次运行时都有变化。实现的方式时：程序开始时，在栈上分配一段 0~n 字节的随机大小的空间。
>
> 在 Linux 系统中，栈随机化已经变成了标准行为。他是更大的一类技术中的一种，这类技术称为地址空间布局随机化（Address-Space Layout Randomization），或者简称 ASLR。采用 ASLR，每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域。

空操作雪橇（nop sled）的枚举次数计算方式是：

- 一个 `nop` 操作命令占用 1 个字节；

- 例如需要破解 n=2^23 的随机化，使用 256 字节的 nop sled；

  每次尝试，一个 256 字节的空操作 sled 会覆盖 2^8 个地址；因此一共需要枚举 (2^23)/(2^8)=2^15 个起始地址；

##### 2. 栈破坏检测

> 最近的 GCC 版本在产生的代码中加入了一种栈保护着（stack protector）机制，来检测缓冲区越界。其思想是在栈帧任何局部缓冲区与栈状态之间存储一个特殊的金丝雀（canary）值。这个金丝雀的值，也称为哨兵值（guard value），是在程序每次运行时随机产生的，因此，攻击者没有简单的办法能够知道它是什么。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了。如果是的，那么程序异常中止。
>
> 最近的 GCC 版本会试着确定一个函数是否容易遭受栈溢出攻击，并且自动插入这种溢出检测。使用命令行选项 `-fno-stack-protector` 来组织 GCC 产生这种代码。
>
> 它只会带来很小的性能损失，**特别是因为 GCC 只在函数中有局部 char 类型缓冲区的时候才插入这样的代码。**

##### 3. 限制可执行代码区域

> 最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。在典型的程序中，只有保存编译器生成的代码的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。
>
> 有些类型的程序要求动态产生和执行代码的能力。例如，“即时（just-in-time）”编译技术为解释语言（例如 Java）编写的程序动态地产生代码，以提高执行性能。是否能够将可执行代码限制在由编译器在创建程序时产生地那个部分中，取决于语言和操作系统。

#### 3.10.5 支持变长栈帧

> 为了管理变长栈帧，x86-64 代码使用寄存器 `%rbp` 作为帧指针（frame pointer）（有时称为基指针（base pointer），这也是 `%rbp` 中 bp 两个字母的由来）。可以看到代码必须把 `%rbp` 之前的值保存到栈中，因为它是一个被调用者保存寄存器。然后在函数的整个执行过程中，都使得 `%rbp` 指向那个时刻栈的位置。
>
> `leave` 指令将帧指针恢复到它之前的值。这条指令不需要参数，等价于执行下面两条指令：
>
> ```assembly
> movq $rbp, $rsp
> popq $rbp
> ```
>
> 也就是说，首先把栈指针设置为保存 `%rbp` 值的位置，然后把该值从栈中弹出到 `%rbp`。这个指令组合具有释放整个栈帧的效果。
>
> 在较早版本的 x86 代码中，每个函数调用都使用了帧指针。而现在，只有栈帧长度可变的情况下才使用。

不一定，之前栈帧长度不可变也使用了。

### 3.11 浮点代码

> 1997 年出现了 Pentium/MMX，Intel 和 AMD 都引入了持续数代的媒体指令，支持图形和图像处理。这些指令本意是允许多个操作以并行模式执行，称为单指令多数据或 SIMD。
>
> 每个扩展都是管理寄存器组中的数据，这些寄存器在 MMX 中称为 “MM” 寄存器，SSE 中称为 ”XMM“ 寄存器，而在 AVX 中称为 ”YMM“ 寄存器；
>
> 我们的讲述基于 AVX2，即 AVX 的第二个版本。当给定命令行参数 `-mavx2` 时，GCC 会生成 AVX2 代码。
>
> 当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低 32 位（对于 float）或 64 位（对于 double）。汇编代码用寄存器的 SSE XMM 寄存器名字 `%xmm0`~`%xmm15` 来引用它们。

**如果不使用命令行参数 `-mavx2` 默认生成的是 SSE 的命令集；**

```bash
gcc -mavx2
```

`AVX2` 命令集更强大，但需要 CPU 支持该命令集；

以下部分命令属于 `avx` 命令集以 `v` 开头，除去 `v` 为 `SSE` 命令集；

#### 3.11.1 浮点传送和转换操作

> 引用内存的指令是标量指令，意味着它们只对单个而不是一组封装好的数据值进行操作。
>
> 无论数据对齐与否，这些指令都能正确执行，不过代码优化规则建议 32 位内存数据满足 4 字节对齐，64 位数据满足 8 字节对齐。
>
> 当用于读写内存时，如果地址不满足 16 字节对齐，它们会导致异常。

GCC 把单精度值转化成双精度值使用

```assembly
vunpcklps %xmm0, %xmm0, %xmm0
vcvtps2pd %xmm0, %xmm0
```

而不是以下命令，该命令在手册上是真实有的；

```assembly
vcvtss2sd %xmm0, %xmm0, %xmm0
```

在 `printf` 中使用 `%f` 打印单精度浮点数时，GCC 会使用最上方的两句指令将单精度转化成双精度后打印；

GCC 把双精度值转化成单精度值使用

```assembly
vmovddup %xmm0, %xmm0
vcvtpd2psx %xmm0, %xmm0
```

而不是

```assembly
vcvtsd2ss %xmm0, %xmm0, %xmm0
```

**浮点数的类型转换的目的地都是寄存器。**

便于理解：

- `vcvttss2si` 的含义为 `Convert with Truncation Scalar Single-Precision Floating-Point Value to Integer`。

- `vunpcklps` 的含义为 `Unpack and Interleave Low Packed Single-Precision Floating Values`。

  [s3, s2, s1, s0], [s7, s6, s5, s4] => [s1, s5, s0 , s4]

- `vcvtps2pd` 的含义为 `Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point`。

  [x3, x2, s1, s0] => [d1, d0]

- `vmovddup` 的含义为 `Replicate Double FP Values`。

  [d1, d0] => [d0, d0]

- `vcvtpd2psx` 的含义为 `Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values`。

  [d1, d0] => [0.0, 0.0, s1, s0]

#### 3.11.2 过程中的浮点代码

- XMM 寄存器最多可以传递 8 个浮点参数；
- 函数使用寄存器 `%xmm0` 来返回浮点值；
- 所有的 XMM 寄存器都是调用者保存的；
- 当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点数通过 XMM 寄存器传递；

#### 3.11.3 浮点运算操作

> 第一个源操作数 S1 可以是一个 XMM 寄存器或一个内存位置。第二个源操作数和目的操作数都必须是 XMM 寄存器。每个操作都有一条针对单精度的指令和一条双精度的指令。结果存放在目的寄存器中。

与整数运算相似，浮点运算一般格式是

```assembly
vsubss 减数, 被减数, 目的寄存器
```

从练习题来看（中间过程），如果运算满足交换律且目的寄存器为源寄存器中一个，都会生成一样的顺序

```assembly
vaddss %xmm0, %xmm2, %xmm0
vmulss %xmm0, %xmm2, %xmm0
```

并不按照上方的一般格式顺序，可能该顺序最优。

#### 3.11.4 定义和使用浮点常数

> 和整数运算操作不同，AVX 浮点操作不能以立即数值作为操作数。相反，编译器必须为所谓的常量值分配和初始化存储空间。然后代码再把这些值从内存读入。

编译器使用（可能）叫段地址的方式访问常量浮点数；注意到汇编代码

```assembly
.align 8
```

对 8 字节进行对齐；但是 AVX 指令读写内存的时候不是要求 16 字节对齐吗？

**虽然编译器声明 2 个 `.long` 来组成一个双精度浮点数，但是只使用每个 `.long` 最低的 4 个字节；**

即使把示例代码中所有 `double` 类型修改成 `float`，编译器仍然会进行双精度浮点数运算，并将结果转换为单精度浮点值；

```c
float cel2fahr(float temp)
{
    return 1.8 * temp + 32.0;
}
```

这可能是因为运算中有浮点常量和乘除运算时，会默认扩展成双精度浮点数进行运算；

```c
float cel2fahr(float temp)
{
    float a = 1.8;
    return a * temp + 32.0;
}
```

使用单精度浮点数变量时，则不需要扩展；注意变量 `a` 初始化的值的存储方式同浮点常数的方式是一致的；

如果只是普通加法，则一个单精度浮点数常量只用一个 `.long` 来声明，并通过 `vaddss` 单精度浮点数运算获取不同字节长度的常量；对齐字节也由 8 变为了 4；

#### 3.11.5 在浮点代码中使用位级操作

书上刊印有些错误；

- 位级异或

  ```assembly
  vxorps
  vxorpd
  ```

- 位级或

  ```assembly
  vorps
  vorpd
  ```

- 位级与

  ```assembly
  vandps
  vandpd
  ```

> 这些指令对一个 XMM 寄存器中的所有 128 位进行布尔操作；

#### 3.11.6 浮点比较操作

书上刊印有些错误；

- `vucomiss` 的含义为 `Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS`。
- `vucomisd` 的含义为 `Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS`。
- `vcomiss` 的含义为 `Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS`。
- `vcomisd` 的含义为 `Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS`。

> The UCOMISS instruction differs from the COMISS instruction in that it signals a SIMD floating-point invalid operation exception (#I) only if a source operand is an SNaN. The COMISS instruction signals an invalid operation exception when a source operand is either a QNaN or SNaN.[^1]
>
> Two separate kinds of NaNs are provided, termed *quiet NaNs* and *signaling NaNs*. Quiet NaNs are used to propagate errors resulting from invalid operations or values. Signaling NaNs can support advanced features such as mixing numerical and symbolic computation or other extensions to basic floating-point arithmetic.[^2]

> 参数 S2 必须在 XMM 寄存器中，而 S1 可以在 XMM 寄存器中，也可以在内存中。
>
> 浮点比较指令会设置三个条件码：零标志位 `ZF`、进位标志位 `ZF` 和奇偶标志位 `PF`。对于整数操作，当最近的一次算术或逻辑运算产生的值的最低位字节是偶校验的（即这个字节中有偶数个 1），那么就会设置这个标志位。不过对于浮点比较，当两个操作数中任一个是 NaN 时，会设置该位。根据惯例，C 语言中如果有个参数为 NaN，就认为比较失败了。
>
> 通常 jp（jump on parity）指令是条件跳转，条件就是浮点比较得到一个无序的结果（PF = 1）。

示例代码第 10 行

```assembly
vucomiss .LC0($rip), %xmm0
```

置位 x - 0 的结果，当

- x - 0 > 0 时，`ZF` 和 `CF` 为 0；
- x 为 `NaN` 时，`ZF` 和 `CF` 都为 1；

```assembly
setbe %al
```

`setbe` 是将寄存器最低字节置为 `ZF|CF` 的结果；

练习题中，一个单精度浮点数乘以一个长整型，只会将长整型转化为单精度浮点数；

#### 3.11.7 对浮点代码的观察结论

> AVX2 还有能力在封装好的数据上执行并行操作，使计算执行得更快。编译器开发者正致力于自动化从标量代码到并行代码的转换，但是目前通过并行化获得更高性能的最可靠的方法是使用 GCC 支持的、操纵向量数据的 C 语言扩展。

### 3.12 小结

> 部分程序状态，如寄存器和运行时栈，对程序员来说是直接可见的。



[^1]: <Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2: Instruction Set Reference, A-Z>
[^2]: https://en.wikipedia.org/wiki/NaN
[^3]: https://docs.microsoft.com/zh-cn/cpp/build/stack-usage?view=msvc-170
[^4]: https://gcc.gnu.org/onlinedocs/gcc-4.2.4/gcc/i386-and-x86_002d64-Options.html

