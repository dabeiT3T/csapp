## Chapter 2

### 2.3 整数运算

#### 2.3.4 无符号乘法

> C 语言中的无符号乘法被定义为产生 w 位的值，就是 2w 位的整数乘积的低 w 位表示的值。
>
> 对满足 0 <= x, y <= UMax(w) 的 x 和 y 有：
> $$
> ux * uy = (ux * uy) mode 2^w
> $$

#### 2.3.5 补码乘法

> C 语言中的有符号乘法是通过将 2w 位的乘积截断为 w 位来实现的。
>
> 对满足 TMin(w) <= x, y <= TMax(w) 的 x 和 y 有：
> $$
> x * y = U2T((x * y) mod 2^w)
> $$
> 我们认为对于无符号和补码乘法来说，乘法运算的位级表示都是一样的。

练习题 2.35 判断两个有符号整数相乘是否会产生移除的解决方案：

```c
/* Determine whether arguments can be multiplied without overflow */
int tmult_ok(int x, int y)
{
    int p = x * y;
    /* Either x is zero or dividing p by x gives y */
    return !x || p/x == y;
}
```

#### 2.3.6 乘以常数

> 以往，在大多数机器上，整数乘法指令相当慢，需要 10 个或者更多的时钟周期，然而其他整数运算（例如加法、减法、位级运算和移位）只需要 1 个时钟周期。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。
>
> 首先，我们会考虑乘以 2 的幂的情况，然后再概括成乘以任意常数。
>
> 左移一个数值等价于执行一个与 2 的幂相乘的无符号乘法。
>
> 例如，假设一个程序包含表达式 x * 14。利用
> $$
> 14 = 2^3 + 2^2 + 2^1
> $$
> 编译器会将乘法重写为
>
> ```c
> (x << 3) + (x << 2) + (x << 1)
> ```
>
> 将一个乘法替换为三个位移和两个加法。更好的是，编译器还可以利用属性
> $$
> 14 = 2^4 - 2^1
> $$
> 将乘法重写为
>
> ```c
> (x << 4) - (x << 1)
> ```
>
> 这是只需要两个位移和一个减法。
>
> 考虑一组从位位置 n 到位位置 m 的连续的 1（n >= m）。（对于 14 来说，我们有 n = 3 和 m = 1。）我们可以用下面两种不同形式中的一种来计算这些位对乘积的影响：
>
> 形式 A：(x<<n) + (x<<(n-1)) + ... + (x<<m)
>
> 形式 B：(x<<(n+1)) - (x<<m)
>
> 把每个这样连续的 1 的结果加起来，不用做任何乘法，我们就能计算出 x * K。

一般的，计算机计算整数乘法类似我们计算十进制乘法，例如十进制乘法
$$
x * 111 = x * 100 + x * 10 + x * 1
$$
假设在只有 3 位的计算机上，x = 0b011 和 y = 0b101；

如果是无符号整数相乘，首先使用 0 填充成 6 位（对于两个 w 位整数相乘，可能会产生 2w 位的乘积），

```
  000 011
* 000 101
---------
  000 011
+ 001 010
---------
  001 111
```

如果是有符号整数相乘，首先使用符号位填充为 6 位，

```
  000 011
* 111 101
---------
  000 011
+ 001 100
+ 011 000
+ 110 000
+ 100 000
---------
  110 111
```

然后取末 3 位即可[^1]。*家庭作业 2.75 基础知识。*

#### 2.3.7 除以 2 的幂

> 在大多数机器上，整数除法要比整数乘法更慢——需要 30 个或者更多的时钟周期。
>
> 无符号和补码数分别使用逻辑位移和算数位移来达到目的。
>
> 对于 x >= 0 和 y > 0，结果会是 ⌊x/y⌋，而对于 x < 0 和 y > 0，结果会是 ⌈x/y⌉。也就是说，它将向下舍入一个正值，而向上舍入一个负值。

实际上 C 语言除法不管符号，结果直接抹去小数；**但是右移操作在负数时，并不符合 C 常规的除法，它将向下舍入。**

> 我们可以通过在位移之前”偏置（biasing）“这个值，来修正这种不合适的舍入。
>
> C 变量 x 和 k 分别有补码值 x 和无符号值 k，且 0 <= k < w，则当执行算数位移时，C 表达式 (x+(1<<k)-1)>>k 产生数值 ⌊x/(2^k)⌋。
>
> 偏置技术利用如下属性：对于整数 x 和 y (y > 0)，⌈x/y⌉ = ⌊(x+y-1)/y⌋。

该技术把向上舍入转化成了向下舍入，使得负数可以通过右移虽然向下舍入但是结果满足常规除法；

[^1]:https://stackoverflow.com/questions/37005446/get-the-32-high-bits-of-multiplying-two-unsigned-integers-hw

