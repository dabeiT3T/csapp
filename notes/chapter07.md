## Chapter 7

> 链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。
>
> 链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译（separate compilation）成为可能。为什么要这么麻烦地学习关于链接地知识呢？
>
> - 理解链接器将帮助你构造大型程序
>
>   构造大型程序地程序员经常会遇到由于缺少模块、缺少库或者不兼容的库版本引起的链接器错误。
>
> - 理解链接器将帮助你避免一些危险的编程错误
>
>   Linux 链接器解析符号引用时所做的决定可以不动声色地影响你程序地正确性。在默认情况下，错误地定义多个全局变量地程序将通过链接器，而不产生任何警告信息。
>
> - 理解链接将帮助你理解语言地作用域规则是如何实现地
>
>   例如，全局和局部变量之间地区别是什么？当你定义一个具有 static 属性的变量或者函数时，实际到底意味着什么？
>
> - 理解链接将使你能够利用共享库
>
>   随着共享库和动态链接在现代操作系统中重要性地日益加强，链接成为一个复杂的过程，为掌握它的程序员提供了强大的能力。比如，许多软件产品在运行时使用共享库来升级压缩包装的 （shrink-wrapped）二进制程序。还有，大多数 Web 服务器都依赖于共享库的动态链接来提供动态内容。
>
> 为了使描述具体和便于理解，我们的讨论基于这样的环境：一个运行 Linux 的 x86-64 系统，使用标准的 ELF-64（此后称为 ELF）目标文件格式。

### 7.1 编译器驱动程序

> 大多数编译系统提供编译器驱动程序（compiler driver），它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。
>
> 驱动程序首先运行 C 预处理器（cpp），它将 C 的源程序 `main.c` 翻译成一个 ASCII 码的中间文件 `main.i`：
>
> ```
> cpp [other arguments] main.c /tmp/main.i
> ```
>
> 接下来，驱动程序运行 C 编译器（ccl），它将 `main.i` 翻译成一个 ASCII 汇编语言文件 `main.s`：
>
> ```
> ccl /tmp/main.i -Og [other arguments] -o /tmp/main.s
> ```
>
> 然后，驱动程序运行汇编器（as），它将 main.s 翻译成一个可重定位目标文件（relocatable object file）`main.o`：
>
> ```
> as [other arguments] -o /tmp/main.o /tmp/main.s
> ```
>
> 驱动程序经过相同的过程生成 `sum.o`。最后，它运行链接器程序 ld，将 `main.o` 和 `sum.o` 以及一些必要的系统目标文件组合起来，创建一个可执行目标文件（executable object file）prog：
>
> ```
> ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o
> ```
>
> shell 调用操作系统中一个叫做加载器（loader）的函数，它将可执行文件中的代码和数据复制到内存，然后将控制转移到这个程序的开头。

### 7.2 静态链接

> 像 Linux LD 程序这样的静态链接器（static linker）以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节（section）组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的变量又在另外一节中。
>
> 为了构造可执行文件，链接器必须完成两个主要任务：
>
> - 符号解析（symbol resolution）
>
>   目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量（即 C 语言中任何以 static 属性声明的变量）。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。
>
> - 重定位（relocation）
>
>   编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编产生的重定位条目（relocation entry）的详细指令，**不加甄别地**执行这样地重定位。
>
>   目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含引导链接器和加载器的数据结构。链接器将这些块连起来，确定被连接块的运行时位置，并且修改代码和数据块中的各个位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。

### 7.3 目标文件

> 目标文件有三种形式：
>
> - 可重定位目标文件
>
>   包含二进制代码和数据，其形式可以在编译时与其他可重定位目标合并起来，创建一个可执行目标文件。
>
> - 可执行目标文件
>
>   包含二进制代码和数据，其形式可以被直接复制到内存并执行。
>
> - 共享目标文件
>
>   一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。
>
> 编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说，一个目标模块（object module）就是一个字节序列，而一个目标文件（object file）就是一个以文件形式存放在磁盘中的目标模块。
>
> 从贝尔实验室诞生的第一个 Unix 系统使用的是 a.out 格式。Windows 使用可移植可执行（Portable Executable，PE）格式。Mac OS-X 使用 Mach-O 格式。现代 x86-64 Linux 和 Unix 系统使用可执行可链接格式（Executable and Linkable Format，ELF）。

### 7.4 可重定位目标文件

> ELF 头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如 x86-64）、节头部表（section header table）的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目（entry）。
>
> 夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：
>
> - .text
>
>   已编译程序的机器代码。
>
> - .rodata
>
>   只读数据，比如 printf 语句中的格式串和开关语句的跳转表。
>
> - .data
>
>   已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，即不出现在 .data 节中，也不出现在 .bss 节中。
>
> - .bss
>
>   未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。
>
>   **为什么未初始化的数据称为 .bss**
>
>   用术语 .bss 来表示未初始化的数据是很普遍的。它起始于 IBM 704 汇编语言（大约在 1957 年）中 “块存储开始（Block Storage Start）” 指令的首字母缩写，并沿用至今。一种记住 .data 和 .bss 节之间区别的简单方法是把 “bss“ 看成是 ”更好地节省空间（Better Save Space）“ 的缩写。
>
> - .symtab
>
>   一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。
>
> - .rel .text
>
>   一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，**任何调用外部函数或者引用全局变量的指令都需要修改**。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。
>
> - .rel .data
>
>   **被模块引用或定义的所有全局变量的重定位信息。**一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。
>
> - .debug
>
>   一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。
>
> - .line
>
>   原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。
>
> - .strtab
>
>   一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。

### 7.5 符号和符号表

> 每个可重定位目标模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：
>
> - 由模块 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数和全局变量。
> - 由其他模块定义并被模块 m 引用的全局变量符号。这些符号称为外部符号，对应于在其他模块中定义的非静态 C 函数和全局变量。
> - 只被模块 m 定义和引用的局部符号。他们对应于带 static 属性的 C 函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用。
>
> .symtab 中的符号表不包含对应于本地**非静态**程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣。
>
> 定义为带有 C static 属性的本地过程变量是不在栈中管理的。相反，编译器在 .data 或 .bss 中为每个定义分配空间，并在符号表中创建一个唯一名字的本地链接器符号。比如，假设在同一模块中的两个函数各自定义了一个静态局部变量 x。在这种情况中，编译器向汇编器输出两个不同名字的局部链接器符号。比如，它可以用 x.1 和 x.2 表示。
>
> **利用 static 属性隐藏变量和函数名字**
>
> C 程序员使用 static 属性隐藏模块内部的变量和函数声明，就像你在 Java 和 C++ 中使用 public
>
> 和 private 声明一样。在 C 中，源文件扮演模块的角色。任何带有 static 属性声明的全局变量或者函数都是模块私有的。类似地，任何不带 static 属性声明的全局变量和函数都是公共的，可以被其他模块访问。尽可能用 static 属性来保护你的变量和函数是很好的编程习惯。
>
> 符号表是由汇编器构造的，使用编译器输出到汇编语言 .s 文件中的符号。.symtab 节中包含 ELF 符号表。这张符号表包含一个条目的数组。
>
> 有三个特殊的伪节（pseudosection），它们在节头部表中是没有条目的：
>
> - ABS 代表不该被重定位的符号；
> - UNDEF 代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号；
> - COMMON 表示还未被分配位置的未初始化的数据目标；value 字段给出对齐要求，而 size 给出最小的大小。
>
> 注意，只有可重定位目标文件中才有这些伪节，可执行目标文件中是没有的。
>
> COMMON 和 .bss 的区别很细微。
>
> - COMMON
>
>   未初始化的全局变量*（弱符号，把决定权留给链接器。）*
>
> - .bss
>
>   未初始化的静态变量，以及初始化为 0 的全局或静态变量
>
> 采用这种看上去很绝对的区分方式的原因来自于链接器执行符号解析的方式，会在 7.6 节中加以解释。
>
> GNU READELF 程序是一个查看目标文件内容的很方便的工具。

### 7.6 符号解析

> 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。
>
> 不过，对全局符号的引用解析就棘手的多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个某块中定义的，生成一个链接器符号表条目，并把它交给连接器处理。如果链接器在它的任何输入模块中都找不到这个被引用的符号的定义，就输出一条（通常很难阅读的）的错误信息并终止。
>
> 对全局符号的符号解析很棘手，还因为多个目标文件可能会定义相同名字的全局符号。在这种情况下，链接器必须要么标志一个错误，要么以某种方式选出一个定义并抛弃其他定义。Linux 系统采纳的方法涉及编译器、汇编器和链接器之间的协作，这样也可能给不警觉的程序员带来一些麻烦。
>
> **对 C++ 和 Java 中链接器符号的重整**
>
> C++ 和 Java 都允许重载方法，这些方法在源代码中有相同的名字，却有不同的参数列表。那么链接器是如何区别这些不同的重载函数之间的差异呢？C++ 和 Java 中能使用重载函数，是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做重整（mangling），而相反的过程叫做恢复（demangling）。
>
> 幸运的是，C++ 和 Java 使用兼容的重整策略。一个被重整的类名字是由名字中字符的整数数量，后面跟原始名字组成的。比如，类 Foo 被编码成 3Foo。方法被编码为原始方法名，后面加上 \__，加上被重整的类名，再加上每个参数的单字母编码。比如，Foo::bar(int, long) 被编码为 bar__3Fooil。重整全局变量和模板名字的策略是相似的。

#### 7.6.1 链接器如何解析多重定义的全局符号

> 如果多个模块定义同名的全局符号，会发生什么呢？下面是 Linux 编译系统采用的方法。
>
> 在编译时，编译器向汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件地符号表里。**函数和已初始化地全局变量是强符号，未初始化地全局变量是弱符号。**
>
> 根据强弱符号地定义，Linux 链接器使用下面地规则来处理多重定义地符号名：
>
> - 规则 1：不允许有多个同名的强符号。
> - 规则 2：如果有一个强符号和多个弱符号同名，那么选择强符号。
> - 规则 3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。
>
> 如果在一个模块里 x 未被初始化，那么链接器将安静地选择在另一个模块中定义的强符号（规则 2）；注意，链接器通常不会表明它检测到多个 x 的定义。
>
> 规则 2 和规则 3 的应用会造成一些不易察觉的运行时错误，对于不警觉的程序员来说，是很难理解的，尤其是如果重复的符号定义还有不同的类型时。
>
> 当怀疑有此类错误时，用像 GCC-fno-common 标志这样的选项调用链接器，这个选项会告诉链接器，在遇到多重定义的全局符号时，触发一个错误。或者使用 -Werror 选项，它会把所有的警告都变为错误。
>
> 在 7.5 节中，我们看到了编译器如何按照一个看似绝对的规则来把符号分配为 COMMON 和 .bss。实际上，采用这个惯例是由于在某些情况中链接器允许多个模块定义同名的全局符号。当编译器在翻译某个模块时，遇到一个弱全局符号，比如说 x，它并不知道其他模块是否也定义了 x，如果是，它无法预测链接器使用 x 的多重定义中的哪一个。所以编译器把 x 分配成 COMMON，把决定权留给链接器。另一方面，如果 x 初始化为 0，那么它是一个强符号（因此根据规则 2 必须是唯一的），所以编译器可以很自信地将它分配成 .bss。类似地，静态符号的构造就必须是唯一的，所以编译器可以自信地把它们分配成 .data 或 .bss。

#### 7.6.2 与静态库链接

> 实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成一个单独的文件，称为静态库（static library），它可以用做链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。
>
> 为什么系统要支持库的概念呢？以 ISO C99 为例，它定义了一组广泛的标准 I/O、字符串操作和整数数学函数，例如 atoi、printf、scanf、strcpy 和 rand。它们在 libc.a 库中，对每个 C 程序来说都是可用的。ISO C99 还在 libm.a 库中定义了一组广泛的浮点数学函数，例如 sin、cos 和 sqrt。
>
> 相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数。比如，使用 C 标准库和数学库中函数的程序可以用形式如下的命令行来编译和链接：
>
> ```bash
> gcc main.c /usr/lib/libm.a /usr/lib/libc.a
> ```
>
> 在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字（实际上，C 编译器驱动程序总是传送 libc.a 给链接器，所以前面提到的对 libc.a 的引用是不必要的）。
>
> 在 Linux 系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀 .a 标识。
>
> 要创建这些函数的一个静态库，我们将使用 AR 工具，如下：
>
> ```bash
> gcc -c addvec.c multvec.c
> ar rcs libvector.a addvec.o multvec.o
> ```
>
> 为了使用这个库，我们可以编写一个应用，它调用 addvec 库例程。包含（或头）文件 vector.h 定义了 libvector.a 中例程的函数原型。
>
> 为了创建这个可执行文件，我们要编译和链接输入文件 main.o 和 libvector.a：
>
> ```bash
> gcc -c main2.c
> gcc -static -o prog2c main2.o /libvector.a
> # 或者等价地使用：
> gcc -static -o prog2c main2.o -L. -lvector
> ```
>
> *在新版本的 linux 系统下安装 glibc-devel、glibc 和 gcc-c++ 时，都不会安装 libc.a，只安装 libc.so。所以当使用 `-static` 时，libc.a 库不能使用。*
>
> ```bash
> yum install glibc-static
> ```
>
> `-static` 参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无须更进一步的链接。`-lvector` 参数是 libvector.a 的缩写，`-L.` 参数高速链接器在当前目录下查找 libvector.a。
>
> 当链接器运行时，它判定 main2.o 引用了 addvec.o 定义的 addvec 符号，所以复制 addvec.o 到可执行文件。因为程序不引用任何由 multvec.o 定义的符号，所以链接器就**不会复制**这个模块到可执行文件。

#### 7.6.3 链接器如何使用静态库来解析引用

> 虽然静态库很有用，但是它们同时也是一个程序员迷惑的源头，原因在于 Linux 链接器使用它们解析外部引用的方式。在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。**（驱动程序自动将命令行中所有的 .c 文件翻译为 .o 文件。）**在这次扫描中，链接器维护一个可重定位目标文件的集合 E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了但是尚未定义的符号）集合 U，以及一个在前面输入文件中已定义的符号集合 D。初始时，E、U 和 D 均为空。
>
> - 对于命令行上的每个输入文件 f，链接器会判断 f 是一个目标文件还是一个存档文件。如果 f 是一个目标文件，那么链接器把 f 添加到 E，修改 U 和 D 来反映 f 中的符号定义和引用，并继续下一个输入文件。
> - 如果 f 是一个存档文件，那么链接器就尝试匹配 U 中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员 m，定义了一个符号来解析 U 中的一个引用，那么就将 m 加到 E 中，并且链接器修改 U 和 D 来反映 m 中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到 U 和 D 都不再发生变化。此时，如何不包含在 E 中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。
> - 如果当链接器完成对命令上输入文件的扫描后，U 是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位 E 中地目标文件，构建输出的可执行文件。
>
> 不幸的是，这种算法会导致一些令人困扰的链接时错误，**因为命令行上的库和目标文件的顺序非常重要**。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。
>
> 关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的（也就是说没有成员引用另一个成员定义的符号），那么这些库就可以以任何顺序放置在命令行的结尾处。另一方面，如果库不是相互相互独立的，那么必须对它们排序，使得对于每个被存档文件的成员外部引用的符号 s，在命令行中至少有一个 s 的定义是在对 s 的引用之后的。
>
> 如果需要满足依赖需求，可以在命令行上重复库。

*注意步骤的第二步，编译器只会保留有用的成员目标文件，没有用到的会被丢弃，才会产生后方引用的无法匹配到相应的定义的情况；如果是目标文件，会全部加入 U 和 D 中，顺序没有那么重要，放在库前即可；*

### 7.7 重定位

> 一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成：
>
> - 重定位节和符号定义
>
>   在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的 .data 节被全部合并成一节，这个节成为输出的可执行目标文件的 .data 节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及输入模块定义的每个符号。当这一步完成时，**程序中的每条指令和全局变量都有唯一的运行时内存地址了。**
>
>   *虽然全局变量有了运行时内存地址，但是代码中对全局变量的引用仍然是符号；*
>
> - 重定位节中的符号引用
>
>   在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目（relocation entry）的数据结构。

#### 7.7.1 重定位条目

> 当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在 .rel .text 中。已初始化数据的重定位条目放在 .rel .data 中。
>
> ELF 定义了 32 中不同的重定位类型，其中两种最基本的重定位类型：
>
> - R_X86_64_PC32
>
>   重定位一个使用 32 位 PC 相对地址的引用。一个 PC 相对地址就是距离程序计数器（PC）的当前运行时值得偏移量。当 CPU 执行一条使用 PC 相对寻址的指令时，它就将指令中编码的 32 位值加上 PC 的当前运行时值，得到有效地址（如 call 指令的目标），PC 值通常是下一条指令在内存中的地址。
>
> - R_X86_64_32
>
>   重定位一个使用 32 位绝对地址的引用。通过绝对寻址，CPU 直接使用在指令中编码的 32 位值作为有效地址，不需要进一步修改。
>
> 这两种重定位类型支持 x86-64 小型代码模型（small code model），该模型假设可执行目标文件中的代码和数据的总体大小小于 2GB，因此在运行时可以用 32 位 PC 相对地址来访问。GCC 默认使用小型代码模型。大于 2GB 的程序可以用 -mcmodel=medium（中型代码模型）和 -mcmodel=large（大型代码模型）标志来编译。

#### 7.7.2 重定位符号引用

ELF 重定位条目的格式：

```c
typedef struct {
    long offset;	/* Offset of the reference to relocate */
    long type:32,   /* Relocation type */
        symbol: 32; /* Symbol table index */
    long addend;    /* Constant part of relocation expression */
} Elf64_Rela;
```

对一下代码产生可重定向目标文件 main.o：

```c
int sum(int *a, int n);

int array[2] = {1, 2};

int main()
{
    int val = sum(array, 2);
    return val;
}
```

使用 objdump 解析可重定向目标文件，这里 `-d` 显示可执行部分的汇编程序内容：

```bash
gcc -d main.o
```

得到

```assembly
0000000000000000 <main>:
   0:	48 83 ec 08          	sub    $0x8,%rsp
   4:	be 02 00 00 00       	mov    $0x2,%esi
   9:	bf 00 00 00 00       	mov    $0x0,%edi
   e:	e8 00 00 00 00       	callq  13 <main+0x13>
  13:	48 83 c4 08          	add    $0x8,%rsp
  17:	c3                   	retq
```

使用标志 `-r` 显示文件中的重定位条目：

```bash
gcc -r main.o
```

```
main.o:     file format elf64-x86-64

RELOCATION RECORDS FOR [.text]:
OFFSET           TYPE              VALUE 
000000000000000a R_X86_64_32       array
000000000000000f R_X86_64_PC32     sum-0x0000000000000004
```

可以看到 `array` 的偏移量（在 `.text` ）中为 0x0a，而 0x0a 的命令为：

```assembly
   9:	bf 00 00 00 00       	mov    $0x0,%edi
```

这句命令即在为调用 `sum` 函数将参数放入寄存器中，因为不知道全局变量 `array` 的地址信息，使用了占位符；其次重定位条目中 `array` 的类型为 `R_X86_64_32`（使用 32 位绝对地址的引用）也就是为什么使用了 4 字节占位符的原因；

`sum` 同理，但是类型为 `R_X86_64_PC32`（使用 32 位 PC 相对地址的引用），需要计算出地址差；

ELF 重定位条目的格式中，

> addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。

书中例子 `addend` 值为 -4，这是因为执行该指令时，PC 已经指向了下一条指令，需要减 4 修正。
$$
PC + OFFSET_{ADDR} = SUM_{ADDR}
$$

$$
OFFSET_{ADDR} = SUM_{ADDR} - PC = SUM_{ADDR} - (SYMBOL_{SUM} + 4)
$$

### 7.8 可执行目标文件

> 示例 C 程序，开始时是一组 ASCII 文本文件，现在已经被转化为一个二进制文件，且这个二进制文件包含加载程序到内存并运行它所需的所有信息。一个典型的 ELF 可执行文件中的各类信息*（内存地址从低到高）*：
>
> - 只读内存段（代码段）
>   - ELF 头
>   - 段头部表（将连续的文件节映射到运行时内存段）
>   - .init
>   - .text
>   - .rodata
> - 读/写内存段（数据段）
>   - .data
>   - .biss
> - 不加载到内存的符号表和调试信息
>   - .symtab
>   - .debug
>   - .line
>   - .strtab
>   - 节头部表（描述目标文件的节）
>
> 可执行目标文件的格式类似于可重定位目标文件的格式。ELF 头描述文件的总体格式。它还包括程序的入口点（entry point），也就是当程序运行时要执行的第一条指令的地址。.text、.rodata 和 .data 节与可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。.init 节定义了一个小函数，叫做 _init，程序的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位），所以它不再需要 .rel 节。
>
> ELF 可执行文件被设计得很容易加载到内存，可执行文件得连续的片（chunk）被映射到连续的内存段。程序头部表（program header table）描述了这种映射关系。
>
> 可执行文件 prog 的程序头部表（地址截断一半为 4 字节）：
>
> ```
> Read-only code segment
> LOAD off    0x00000000 vaddr 0x00400000 paddr 0x00000000 align 2**21
>      filesz 0x0000069c memsz 0x0000069c flags r-x
> 
> Read/write data segment
> LOAD off    0x00000df8 vaddr 0x00600df8 paddr 0x00600df8 align 2**21
>      filesz 0x00000228 memsz 0x00000230 flags rw-
> ```
>
> off：目标文件中的偏移；vaddr/paddr 内存地址；align：对齐要求；fizesz：目标文件中的段大小；memsz：内存中的段大小；flags：运行时访问权限。
>
> 从程序头部表，我们会看到根据可执行目标文件的内容初始化两个内存段。第 1 行和第 2 行告诉我们第一个段（代码段）有读/执行访问权限，开始于内存地址 0x400000 处，总共的内存大小是 0x69c 字节，并且被初始化为可执行目标文件的头 0x69c 个字节，其中包括 ELF 头、程序头部表以及 .init、.text 和 .rodata 节。
>
> 第 3 行和第 4 行告诉我们第二个段（数据段）有读/写访问权限，开始于内存地址 0x600df8 处，总的内存大小为 0x230 字节，并用从目标文件中偏移 0xdf8 处开始的 .data 节中的 0x228 个字节初始化。该段中剩下的 8 个字节对应运行时将被初始化为 0 的 .bss 数据。
>
> 对于任何段 s，链接器必须选择一个起始地址 vaddr，使得
> $$
> vaddr\ mod\ align = off\ mod\ align
> $$
> 这里，off 是目标文件中段的第一个节的偏移量，align 是程序头部中指定的对齐（2^21 = 0x200000）。例如，上方的数据段中
> $$
> vaddr\ mod\ align = 0x600df8\ mod\ 0x200000 = 0xdf8
> $$
> 以及
> $$
> off\ mod\ align = 0xdf8\ mod 0x200000 = 0xdf8
> $$
> 这个对齐要求是一种优化，使得当程序执行时，目标文件中的段能够很有效率地传送到内存中。原因有点儿微妙，在于虚拟内存的组织方式，它被组织成一些很大的、连续的、大小为 2 的幂的字节片。第 9 张会学习到虚拟内存的知识。

### 7.9 加载可执行目标文件

> shell 通过调用某个驻留在存储器中称为加载器（loader）的操作系统代码来运行可执行目标文件。任何 Linux 程序都可以通过调用 execve 函数来调用加载器（8.4.6 节中详细描述）。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。
>
> 每个 Linux 程序都有一个运行时内存映像，类似于（内存地址从高到低）：
>
> - 内核内存（对用户代码不可见的内存）
>
> - 用户栈（运行时创建）<- %rsp（栈指针）
>
>   向内存地址低位延伸；
>
> - 共享库的内存映射区域
>
>   图中看，向内存地址高位延伸；
>
> - 运行时堆（由 malloc 创建）<- brk
>
> - 读/写段（.data，.bss）（从可执行文件中加载）
>
> - 只读代码段（.init，.text，.rodata）（从可执行文件中加载）@0x400000
>
> 在 Linux x86-64 系统中，代码段总是从地址 0x400000 处开始，后面是数据段。运行时堆在数据段之后，通过调用 malloc 库往上增长。（9.9 节中详细描述 malloc 和堆。）堆后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址*（原书勘误，不是 2^48-1，更小且每个进程不同。）*开始，向较小内存地址增长。栈上的区域，是为内核（kernel）中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分。
>
> 为了简洁，我们把堆、数据和代码段画得彼此相邻，并且把栈顶放在了最大的合法用户地址处。实际上，由于 .data 段有对齐要求，所以代码段和数据段之间是有间隙的。同时，在分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间布局随机化（ASLR）。**虽然每次程序运行时这些区域的地址都会改变，它们的相对位置是不变的。**
>
> 在程序头部表的引导下，加载器将可执行文件的片（chunk）复制到代码段和数据段。接下来，加载器跳转到程序的入口点，也就是 \_start 函数的地址。这个函数是在系统目标文件 ctrl.o 中定义的，对所有的 C 程序都是一样的。\_start 函数调用系统启动函数 \__libc_start_main，该函数定义在 libc.so 中。它初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核。
>
> **加载器实际是如何工作的？**
>
> 我们对于加载的描述从概念上来说是正确的，但也不是完全准确，这是有意为之。要理解加载实际是如何工作的，你必须理解进程、虚拟内存和内存映射的概念。在后面第 8 章和第 9 章中遇到这些概念时，我们将重新回到加载的问题上，并逐渐揭开它的神秘面纱。
>
> 对于不够有耐心的读者，下面是关于加载实际是如何工作的一个概述：Linux 系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当 shell 运行一个程序时，父 shell 进程生成一个子进程，它是父进程的一个复制。子进程通过 execve 系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片（chunk），新的代码和数据段被初始化为可执行文件的内容。最后，加载器跳转到 \_start 地址，它最终会调用应用程序的 main 函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到 CPU 引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。

### 7.10 动态链接共享库

> 静态库有一些明显的缺点。静态库和所有的软件一样，需要定期维护和更新。如果应用程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们地程序与更新了地库重新链接。
>
> 另一个问题是几乎每个 C 程序都使用标准 I/O 函数，比如 printf 和 scanf。在运行时，这些函数地代码会被复制到每个运行进程地文本段中。在一个运行上百个进程地典型系统上，这将是对稀缺地内存系统资源地极大浪费。（内存地一个有趣属性就是不论系统的内存有多大，它总是一种稀缺资源。）
>
> 共享库（shared library）是一个目标模块，在运行或加载时，可以加载到任意地内存地址，并和一个在内存中的程序连接起来。这个过程称为动态链接（dynamic linking），是由一个叫做动态链接器（dynamic linker）的程序来执行的。共享库也称为共享目标（shared object），在 Linux 系统中通常用 .so 后缀来表示。微软的操作系统大量地使用了共享库，它们称为 DLL （动态链接库）。
>
> 共享库是以两种不同地方式来 “共享” 的。首先，在任何给定的文件系统中，对于一个库只有一个 .so 文件。所有引用该库的可执行目标文件共享这个 .so 文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。其次，才内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享。在第 9 章学习虚拟内存时将更详细地讨论这个问题。
>
> 为了构造示例向量例程的共享库 libvector.so，调用编译器驱动程序，给编译器和链接器如下特殊指令：
>
> ```bash
> gcc -shared -fpic -o libvector.so addvec.c multvec.c
> ```
>
> `-fpic` 选项指示编译器生成与位置无关的代码（下一节将详细讨论这个问题）。`-shared` 选项指示链接器创建一个共享的目标文件。一旦创建了这个库，随后就要将它链接到示例程序中：
>
> ```bash
> gcc -o prog21 main2.c ./libvector.so
> ```
>
> 此文件的形式使得它在运行时可以和 libvector.so 链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。认识到这一点是很重要的：此时，没有任何 libvector.so 的代码和数据节点真的被复制到可执行文件 prog21 中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对 libvector.so 中代码和数据的引用。
>
> 当加载器加载和运行可执行文件 prog21 时，它利用 7.9 节中讨论过的技术，加载部分链接的可执行文件 prog21。接着，它注意到 prog21 包含一个 .interp 节，这一节包含动态链接器的路径名，动态链接器本身就是一个共享目标（如在 Linux 系统上的 ld-linux.so）。加载器不会像它通常所做的那样将控制传递给应用，而是加载和运行这个动态链接器。然后，动态链接器通过执行下面的重定位完成链接任务：
>
> - 重定位 libc.so 的文本和数据到某个内存段。
> - 重定位 libvector.so 的文本和数据到某个内存段。
> - 重定位 prog21 中所有对由 libc.so 和 libvector.so 定义的符号的引用。
>
> 随后，动态链接器将控制传递给应用程序。**从这个时刻开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变。**

### 7.11 从应用程序中加载和链接共享库

> **应用程序还可能在它运行时要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接到应用中。**
>
> 动态链接是一项强大有用的技术。下面是一些现实世界中的例子：
>
> - 分发软件
>
>   微软 Windows 应用的开发者常常利用共享库来分发软件更新。他们生成一个共享库的新版本，然后用户可以下载，并用它替代当前的版本。下一次他们运行应用程序时，应用将自动链接和加载新的共享库。
>
> - 构建高性能 Web 服务器
>
>   许多 Web 服务器生成动态内容，比如个性化的 Web 页面、账户余额和广告标语。早期的 Web 服务器通过使用 fork 和 execve 创建一个子进程，并在该子进程的上下文中运行 CGI 程序来生成动态内容。然而，现代高性能的 Web 服务器可以使用基于动态链接的更有效和完善的方法来生成动态内容。
>
> 其思路是将每个生成动态内容的函数打包在共享库中。当一个来自 Web 浏览器的请求到达时，服务器动态地加载和链接适当的函数，然后直接调用它，而不是使用 fork 和 execve 在子进程的上下文中运行函数。函数会一直缓存在服务器的地址空间中，所以只要一个简单的函数调用的开销就可以处理随后的请求了。更进一步地说，在运行时无需停止服务器，就可以更新已存在的函数，以及添加新的函数。
>
> Linux 系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库。
>
> ```c
> #include <dlfcn.h>
> void *dlopen(const char *filename, int flag);
> // 返回：若成功则为指向句柄的指针，若出错则为 NULL
> ```
>
> dlopen 函数加载和链接共享库 filename。用已用带 RTLD_GLOBAL 选项打开了的库解析 filename 中的外部符号。如果当前可执行文件是带 -rdynamic 选项编译的，那么对符号解析而言，它的全局符号也是可用的。flag 参数必须要么包括 RTLD_NOW，该标志告诉链接器立即解析对外部符号的引用，要么包括 RTLD_LAZY 标志，该标志指示链接器推迟符号解析直到执行来自库中的代码。这两个值中的任意一个都可以和 RTLD_GLOBAL 标志取或。
>
> ```c
> #include <dlfcn.h>
> void *dlsym(void *handle, char *symbol);
> // 返回：若成功则为指向符号的指针，若出错则为 NULL
> ```
>
> dlsym 函数的输入是一个指向前面已经打开了的共享库的句柄和一个 symbol 名字，如果该符号存在，就返回符号的地址，否则返回 NULL。*symbol 即符号/函数的名称，例如 "addvec"；*
>
> ```c
> #include <dlfcn.h>
> int dlclose(void *handle);
> // 返回：若成功则为 0，若出错则为 -1
> ```
>
> 如果没有其他共享库还在使用这个共享库，dlclose 函数就卸载该共享库。
>
> ```c
> #include <dlfcn.h>
> const char *dlerror(void);
> // 返回：如果前面对 dlopen、dlsym 或 dlclose 的调用失败，则为错误消息
> // 如果前面的调用成功，则为 NULL
> ```
>
> dlerror 函数返回一个字符串，它描述的是调用 dlopen、dlsym 或者 dlclose 函数时发生的最近的错误，如果没有错误发生，就返回 NULL。
>
> 要编译程序，将以下面的方式调用 GCC：
>
> ```bash
> gcc -rdynamic -o prog2r dll.c -ldl
> ```
>
> **共享库和 Java 本地接口**
>
> Java 定义了一个标准调用规则，叫做 Java 本地接口（Java Native Interface，JNI），它允许 Java 程序调用 “本地的” C 和 C++ 函数。JNI 的基本思想是将本地 C 函数（如 foo）编译到一个共享库中（如 foo.so）。当一个正在运行的 Java 程序试图调用函数 foo 时，Java 解释器利用 dlopen 接口（或者与其类似的接口）动态链接和加载 foo.so，然后再调用 foo。

### 7.12 位置无关代码

> 共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，因而解决宝贵的内存资源。多个进程共享程序的一个副本的一种方法是给每个共享库分配一个事先预备的专用的地址空间片，然后要求加载器总是在这个地址加载共享库。虽然这种方法很简单，但是它也造成了一些严重的问题。它对地址空间的使用效率不高，因为即使一个进程不使用这个库，那部分空间还是会被分配出来。它也难以管理。我们必须保证没有片会重叠。每次当一个库修改之后，我们必须确认已分配给它的片还适合它的大小。如果不合适了，必须找一个新的片。并且，如果创建了一个新的库，我们还必须为它寻找空间。随着时间的进展，假设在一个系统中有了成百个库和库的各个版本库，就很难避免地址空间分裂成大量小的、未使用而又不再使用的小洞。更糟的是，对每个系统而言，库在内存中的分配都是不同的，这就引起了更多令人头痛的管理问题。
>
> 要避免这些问题，现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需链接器修改。使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本。（当然，每个进程仍然会有它自己的读/写数据块。）
>
> 可以加载而无需重定位的代码称为位置无关代码（Position-Independent Code，PIC）。用户对 GCC 使用 `-fpic` 选项指示 GNU 编译系统生成 PIC 代码。共享库的编译必须总是使用该选项。
>
> 1. PIC 数据引用
>
>    编译器通过运用一下这个有趣的事实来生成对全局变量的 PIC 引用：无论我们在内存中的何处加载一个目标模块（包括共享目标模块），数据段和代码段的距离总是保持不变。因此，代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的。
>
>    想要生成对全局变量 PIC 引用的编译器利用了这个事实，它在数据段开始的地方创建了一个表，叫做全局偏移量表（Global Offset Table，GOT）。在 GOT 中，每个被这个目标模块引用的全局数据目标（过程或全局变量）都有一个 8 字节条目。编译器还为 GOT 中每个条目生成一个重定位记录。在加载时，动态链接器会重定位 GOT 中的每个条目，使得它包含目标的正确的绝对地址。每个引用全局目标的目标模块都有自己的 GOT。
>
>    *编写一个含有全局变量的共享模块：*
>
>    ```c
>    // share.c
>    int a = 100;
>    
>    int add(int b)
>    {
>        return a + b;
>    }
>    ```
>
>    *编译为共享库：*
>
>    ```bash	
>    gcc -shared -fpic -o libshare.so share.c
>    ```
>
>    *使用 ` objdump` 查看共享库所有节点内容：*
>
>    ```bash
>    objdump -D libshare.so
>    ```
>
>    ```assembly
>    0000000000000695 <add>:
>     695:	55                   	push   %rbp
>     696:	48 89 e5             	mov    %rsp,%rbp
>     699:	89 7d fc             	mov    %edi,-0x4(%rbp)
>     69c:	48 8b 05 3d 09 20 00 	mov    0x20093d(%rip),%rax # 200fe0 <a@@Base-0x48>
>     6a3:	8b 10                	mov    (%rax),%edx
>     6a5:	8b 45 fc             	mov    -0x4(%rbp),%eax
>     6a8:	01 d0                	add    %edx,%eax
>     6aa:	5d                   	pop    %rbp
>     6ab:	c3                   	retq
>    ```
>
>    *`69c` 行即将全局变量 `a` 的地址存入 `%rax` 中，通过计算可得出地址为 `0x200fe0`，注释中的括号代表了该地址同样是变量 `a` 的实际地址减去 `0x48`（见后文）；*
>
>    *查看共享库动态重定位条目：*
>
>    ```bash
>    objdump -R libshare.so
>    ```
>
>    ```
>    libshare.so:     file format elf64-x86-64
>    
>    DYNAMIC RELOCATION RECORDS
>    OFFSET           TYPE              VALUE 
>    0000000000200df0 R_X86_64_RELATIVE  *ABS*+0x0000000000000660
>    0000000000200df8 R_X86_64_RELATIVE  *ABS*+0x0000000000000620
>    0000000000200e08 R_X86_64_RELATIVE  *ABS*+0x0000000000200e08
>    0000000000200fd0 R_X86_64_GLOB_DAT  _ITM_deregisterTMCloneTable
>    0000000000200fd8 R_X86_64_GLOB_DAT  __gmon_start__
>    0000000000200fe0 R_X86_64_GLOB_DAT  a@@Base
>    0000000000200fe8 R_X86_64_GLOB_DAT  _Jv_RegisterClasses
>    0000000000200ff0 R_X86_64_GLOB_DAT  _ITM_registerTMCloneTable
>    0000000000200ff8 R_X86_64_GLOB_DAT  __cxa_finalize@GLIBC_2.2.5
>    0000000000201018 R_X86_64_JUMP_SLOT  __gmon_start__
>    0000000000201020 R_X86_64_JUMP_SLOT  __cxa_finalize@GLIBC_2.2.5
>    ```
>
>    *全局变量 `a` 的引用地址的确是 `0x200fe0`；查看具体内容：*
>
>    ```bash
>    objdump -s libshare.so
>    ```
>
>    ```
>    Contents of section .dynamic:
>     200e10 01000000 00000000 79000000 00000000  ........y.......
>    ...
>    Contents of section .got:
>     200fd0 00000000 00000000 00000000 00000000  ................
>     200fe0 00000000 00000000 00000000 00000000  ................
>     200ff0 00000000 00000000 00000000 00000000  ................
>    Contents of section .got.plt:
>     201000 100e2000 00000000 00000000 00000000  .. .............
>     201010 00000000 00000000 96050000 00000000  ................
>     201020 a6050000 00000000                    ........        
>    Contents of section .data:
>     201028 64000000                             d...            
>    Contents of section .comment:
>     0000 4743433a 2028474e 55292034 2e382e35  GCC: (GNU) 4.8.5
>     0010 20323031 35303632 33202852 65642048   20150623 (Red H
>     0020 61742034 2e382e35 2d343429 00        at 4.8.5-44).   
>    ```
>
>    *地址 `0x200fe0` 实际在 `GOT` 中，该地址起的 8 字节包含目标的正确的绝对地址（在加载时，动态链接器会重定位 `GOT` 中的每个条目，所以目前全是 `0`）。而全局变量 `a` 的地址 `0x201028` 减去上方括号中的 `0x48`，也是 `200fe0`；*
>
> 2. PIC 函数调用
>
>    假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方式是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。不过，这种方法并不是 PIC，因为它需要链接器修改调用模块的代码段，GNU 编译系统使用了一种很有趣的技术来解决这个问题，称为延迟绑定（lazy binding），将过程地址的绑定推迟到第一次调用该过程时。
>
>    使用延迟绑定的动机是对于一个像 libc.so 这样的共享库输出的成百上千个函数中，一个典型的应用程序只会使用其中很少的一部分。把函数地址的解析推迟到它实际被调用的地方，能避免动态链接器在加载时进行成百上千个其实并不需要的重定位。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接的内存引用。
>
>    延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是：GOT 和过程链接表（Procedure Linkage Table，PLT）。如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己的 GOT 和 PLT。GOT 是数据段的一部分，而 PLT 是代码段的一部分。
>
>    - 过程链接表（PLT）
>
>      PLT 是一个数组，其中每个条目是 16 字节代码。PLT[0] 是一个特殊条目，它跳转到动态链接器中。
>
>      *上方  `.got .plt` 节点的第一条为 `0x200e10` 即为 `.dynamic` 节点的首地址；*
>
>      每个被可执行程序调用的库函数都有它自己的 PLT 条目。每个条目都负责调用一个具体的函数。PLT[1] 调用系统启动函数（__libc_start_main），它初始化执行环境，调用 main 函数并处理其返回值。从 PLT[2] 开始的条目调用用户代码调用的函数。
>
>    - 全局偏移量表（GOT）
>
>      GOT 是一个数组，其中每个条目是 8 字节地址。和 PLT 联合使用时，GOT[0] 和 GOT[1] 包含动态链接器在解析地址时会使用的信息。GOT[2] 是动态链接器在 ld-linux.so 模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的 PLT 条目。初始时，每个 GOT 条目都指向对应 PLT 条目的第二条指令。
>
>    例如，GOT[4] 和 PLT[2] 对应于 addvec，在 addvec 被第一次调用时，延迟解析它的运行时地址：
>
>    - 不直接调用 addvec，程序调用进入 PLT[2]，这是 addvec 的 PLT 条目。
>
>    - 第一条 PLT 指令通过 GOT[4] 进行间接跳转。因为每个 GOT 条目初始时都指向它对应的 PLT 条目的第二条指令，这个间接跳转只是简单地把控制传送回 PLT[2] 中的下一条指令。
>
>      ```
>      # .GOT
>      GOT[4]: 0x4005c6
>      # .PLT
>      # PLT[2]: call addvec()
>      4005c0: jmpq *GOT[4]
>      4005c6: pushq $0x1
>      4005cb: jmpq 4005a0
>      ```
>
>    - 在把 addvec 的 ID（0x1）压入栈中之后，PLT[2] 跳转到 PLT[0]。
>
>      ```
>      # .GOT
>      GOT[0]: addr of .dynamic
>      GOT[1]: addr of reloc entries
>      GOT[2]: addr of dynamic linker
>      # .PLT
>      # PLT[0]: call dynamic linker
>      4005a0: pushq *GOT[1]
>      4005a6: jmpq *GOT[2]
>      ```
>
>    - PLT[0] 通过 GOT[1] 间接地把动态链接器的一个参数压入栈中，然后通过 GOT[2] 间接跳转进动态链接器中。动态链接器使用两个栈条目来确定 addvec 的运行时位置，用这个地址重写 GOT[4]，再把控制传递给 addvec。
>
>      ```
>      # .GOT
>      GOT[4]: &addvec()
>      ```
>
>    后续再调用 addvec 时的控制流：
>
>    - 和前面一样，控制传递到 PLT[2]。
>    - 不过这次通过 GOT[4] 的间接跳转会将控制直接转移到 addvec。

