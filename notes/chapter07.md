## Chapter 7

> 链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。
>
> 链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译（separate compilation）成为可能。为什么要这么麻烦地学习关于链接地知识呢？
>
> - 理解链接器将帮助你构造大型程序
>
>   构造大型程序地程序员经常会遇到由于缺少模块、缺少库或者不兼容的库版本引起的链接器错误。
>
> - 理解链接器将帮助你避免一些危险的编程错误
>
>   Linux 链接器解析符号引用时所做的决定可以不动声色地影响你程序地正确性。在默认情况下，错误地定义多个全局变量地程序将通过链接器，而不产生任何警告信息。
>
> - 理解链接将帮助你理解语言地作用域规则是如何实现地
>
>   例如，全局和局部变量之间地区别是什么？当你定义一个具有 static 属性地变量或者函数时，实际到底意味着什么？
>
> - 理解链接将使你能够利用共享库
>
>   随着共享库和动态链接在现代操作系统中重要性地日益加强，链接成为一个复杂的过程，为掌握它的程序员提供了强大的能力。比如，许多软件产品在运行时使用共享库来升级压缩包装的 （shrink-wrapped）二进制程序。还有，大多数 Web 服务器都依赖于共享库的动态链接来提供动态内容。
>
> 为了使描述具体和便于理解，我们的讨论基于这样的环境：一个运行 Linux 的 x86-64 系统，使用标准的 ELF-64（此后称为 ELF）目标文件格式。

### 7.1 编译器驱动程序

> 大多数编译系统提供编译器驱动程序（compiler driver），它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。
>
> 驱动程序首先运行 C 预处理器（cpp），它将 C 的源程序 `main.c` 翻译成一个 ASCII 码的中间文件 `main.i`：
>
> ```
> cpp [other arguments] main.c /tmp/main.i
> ```
>
> 接下来，驱动程序运行 C 编译器（ccl），它将 `main.i` 翻译成一个 ASCII 汇编语言文件 `main.s`：
>
> ```
> ccl /tmp/main.i -Og [other arguments] -o /tmp/main.s
> ```
>
> 然后，驱动程序运行汇编器（as），它将 main.s 翻译成一个可重定位目标文件（relocatable object file）`main.o`：
>
> ```
> as [other arguments] -o /tmp/main.o /tmp/main.s
> ```
>
> 驱动程序经过相同的过程生成 `sum.o`。最后，它运行链接器程序 ld，将 `main.o` 和 `sum.o` 以及一些必要的系统目标文件组合起来，创建一个可执行目标文件（executable object file）prog：
>
> ```
> ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o
> ```
>
> shell 调用操作系统中一个叫做加载器（loader）的函数，它将可执行文件中的代码和数据复制到内存，然后将控制转移到这个程序的开头。

### 7.2 静态链接

> 像 Linux LD 程序这样的静态链接器（static linker）以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节（section）组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的变量又在另外一节中。
>
> 为了构造可执行文件，链接器必须完成两个主要任务：
>
> - 符号解析（symbol resolution）
>
>   目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量（即 C 语言中任何以 static 属性声明的变量）。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。
>
> - 重定位（relocation）
>
>   编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编产生的重定位条目（relocation entry）的详细指令，不加甄别地执行这样地重定位。
>
>   目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含引导链接器和加载器的数据结构。链接器将这些块连起来，确定被连接块的运行时位置，并且修改代码和数据块中的各个位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。

### 7.3 目标文件

> 目标文件有三种形式：
>
> - 可重定位目标文件
>
>   包含二进制代码和数据，其形式可以在编译时与其他可重定位目标合并起来，创建一个可执行目标文件。
>
> - 可执行目标文件
>
>   包含二进制代码和数据，其形式可以被直接复制到内存并执行。
>
> - 共享目标文件
>
>   一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。
>
> 编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说，一个目标模块（object module）就是一个字节序列，而一个目标文件（object file）就是一个以文件形式存放在磁盘中的目标模块。
>
> 从贝尔实验室诞生的第一个 Unix 系统使用的是 a.out 格式。Windows 使用可移植可执行（Portable Executable，PE）格式。Mac OS-X 使用 Mach-O 格式。现代 x86-64 Linux 和 Unix 系统使用可执行可链接格式（Executable and Linkable Format，ELF）。

### 7.4 可重定位目标文件

> ELF 头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF 头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如 x86-64）、节头部表（section header table）的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目（entry）。
>
> 夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：
>
> - .text
>
>   已编译程序的机器代码。
>
> - .rodata
>
>   只读数据，比如 printf 语句中的格式串和开关语句的跳转表。
>
> - .data
>
>   已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，即不出现在 .data 节中，也不出现在 .bss 节中。
>
> - .bss
>
>   未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。
>
>   **为什么未初始化的数据称为 .bss**
>
>   用术语 .bss 来表示未初始化的数据是很普遍的。它起始于 IBM 704 汇编语言（大约在 1957 年）中 “块存储开始（Block Storage Start）” 指令的首字母缩写，并沿用至今。一种记住 .data 和 .bss 节之间区别的简单方法是把 “bss“ 看成是 ”更好地节省空间（Better Save Space）“ 的缩写。
>
> - .symtab
>
>   一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。
>
> - .rel .text
>
>   一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。
>
> - .rel .data
>
>   被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。
>
> - .debug
>
>   一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。
>
> - .line
>
>   原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。
>
> - .strtab
>
>   一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。

### 7.5 符号和符号表

> 每个可重定位目标模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：
>
> - 由模块 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数和全局变量。
> - 由其他模块定义并被模块 m 引用的全局变量符号。这些符号称为外部符号，对应于在其他模块中定义的非静态 C 函数和全局变量。
> - 只被模块 m 定义和引用的局部符号。他们对应于带 static 属性的 C 函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用。
>
> .symtab 中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣。
>
> 定义为带有 C static 属性的本地过程变量是不在栈中管理的。相反，编译器在 .data 或 .bss 中为每个定义分配空间，并在符号表中创建一个唯一名字的本地链接器符号。比如，假设在同一模块中的两个函数各自定义了一个静态局部变量 x。在这种情况中，编译器向汇编器输出两个不同名字的局部链接器符号。比如，它可以用 x.1 和 x.2 表示。
>
> **利用 static 属性隐藏变量和函数名字**
>
> C 程序员使用 static 属性隐藏模块内部的变量和函数声明，就像你在 Java 和 C++ 中使用 public
>
> 和 private 声明一样。在 C 中，源文件扮演模块的角色。任何带有 static 属性声明的全局变量或者函数都是模块私有的。类似地，任何不带 static 属性声明的全局变量和函数都是公共的，可以被其他模块访问。尽可能用 static 属性来保护你的变量和函数是很好的编程习惯。
>
> 符号表是由汇编器构造的，使用编译器输出到汇编语言 .s 文件中的符号。.symtab 节中包含 ELF 符号表。这张符号表包含一个条目的数组。
>
> 有三个特殊的伪节（pseudosection），它们在节头部表中是没有条目的：
>
> - ABS 代表不该被重定位的符号；
> - UNDEF 代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号；
> - COMMON 表示还未被分配位置的未初始化的数据目标；value 字段给出对齐要求，而 size 给出最小的大小。
>
> 注意，只有可重定位目标文件中才有这些伪节，可执行目标文件中是没有的。
>
> COMMON 和 .bss 的区别很细微。
>
> - COMMON
>
>   未初始化的全局变量
>
> - .bss
>
>   未初始化的静态变量，以及初始化为 0 的全局或静态变量
>
> 采用这种看上去很绝对的区分方式的原因来自于链接器执行符号解析的方式，会在 7.6 节中加以解释。
>
> GNU READELF 程序是一个查看目标文件内容的很方便的工具。

### 7.6 符号解析

> 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。
>
> 不过，对全局符号的引用解析就棘手的多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个某块中定义的，生成一个链接器符号表条目，并把它交给连接器处理。如果链接器在它的任何输入模块中都找不到这个被引用的符号的定义，就输出一条（通常很难阅读的）的错误信息并终止。
>
> 对全局符号的符号解析很棘手，还因为多个目标文件可能会定义相同名字的全局符号。在这种情况下，链接器必须要么标志一个错误，要么以某种方式选出一个定义并抛弃其他定义。Linux 系统采纳的方法涉及编译器、汇编器和链接器之间的协作，这样也可能给不警觉的程序员带来一些麻烦。
>
> **对 C++ 和 Java 中链接器符号的重整**
>
> C++ 和 Java 都允许重载方法，这些方法在源代码中有相同的名字，却有不同的参数列表。那么链接器是如何区别这些不同的重载函数之间的差异呢？C++ 和 Java 中能使用重载函数，是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做重整（mangling），而相反的过程叫做恢复（demangling）。
>
> 幸运的是，C++ 和 Java 使用兼容的重整策略。一个被重整的类名字是由名字中字符的整数数量，后面跟原始名字组成的。比如，类 Foo 被编码成 3Foo。方法被编码为原始方法名，后面加上 \__，加上被重整的类名，再加上每个参数的单字母编码。比如，Foo::bar(int, long) 被编码为 bar__3Fooil。重整全局变量和模板名字的策略是相似的。

#### 7.6.1 链接器如何解析多重定义的全局符号

> 如果多个模块定义同名的全局符号，会发生什么呢？下面是 Linux 编译系统采用的方法。
>
> 在编译时，编译器向汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件地符号表里。函数和已初始化地全局变量是强符号，未初始化地全局变量是弱符号。
>
> 根据强弱符号地定义，Linux 链接器使用下面地规则来处理多重定义地符号名：
>
> - 规则 1：不允许有多个同名地强符号。
> - 规则 2：如果有一个强符号和多个弱符号同名，那么选择强符号。
> - 规则 3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。
>
> 如果在一个模块里 x 未被初始化，那么链接器将安静地选择在另一个模块中定义地强符号（规则 2）；注意，链接器通常不会表明它检测到多个 x 的定义。
>
> 规则 2 和规则 3 的应用会造成一些不易察觉的运行时错误，对于不警觉的程序员来说，是很难理解的，尤其是如果重复的符号定义还有不同的类型时。
>
> 当怀疑有此类错误时，用像 GCC-fno-common 标志这样的选项调用链接器，这个选项会告诉链接器，在遇到多重定义的全局符号时，触发一个错误。或者使用 -Werror 选项，它会把所有的警告都变为错误。
>
> 在 7.5 节中，我们看到了编译器如何按照一个看似绝对的规则来把符号分配为 COMMON 和 .bss。实际上，采用这个惯例是由于在某些情况中链接器允许多个模块定义同名的全局符号。当编译器在翻译某个模块时，遇到一个弱全局符号，比如说 x，它并不知道其他模块是否也定义了 x，如果是，它无法预测链接器使用 x 的多重定义中的哪一个。所以编译器把 x 分配成 COMMON，把决定权留给链接器。另一方面，如果 x 初始化为 0，那么它是一个强符号（因此根据规则 2 必须是唯一的），所以编译器可以很自信地将它分配成 .bss。类似地，静态符号的构造就必须是唯一的，所以编译器可以自信地把它们分配成 .data 或 .bss。

#### 7.6.2 与静态库链接

> 实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成一个单独的文件，称为静态库（static library），它可以用做链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。
>
> 为什么系统要支持库的概念呢？以 ISO C99 为例，它定义了一组广泛的标准 I/O、字符串操作和整数数学函数，例如 atoi、printf、scanf、strcpy 和 rand。它们在 libc.a 库中，对每个 C 程序来说都是可用的。ISO C99 还在 libm.a 库中定义了一组广泛的浮点数学函数，例如 sin、cos 和 sqrt。
>
> 相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数。比如，使用 C 标准库和数学库中函数的程序可以用形式如下的命令行来编译和链接：
>
> ```bash
> gcc main.c /usr/lib/libm.a /usr/lib/libc.a
> ```
>
> 在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字（实际上，C 编译器驱动程序总是传送 libc.a 给链接器，所以前面提到的对 libc.a 的引用是不必要的）。
>
> 在 Linux 系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀 .a 标识。
>
> 要创建这些函数的一个静态库，我们将使用 AR 工具，如下：
>
> ```bash
> gcc -c addvec.c multvec.c
> ar rcs libvector.a addvec.o multvec.o
> ```
>
> 为了使用这个库，我们可以编写一个应用，它调用 addvec 库例程。包含（或头）文件 vector.h 定义了 libvector.a 中例程的函数原型。
>
> 为了创建这个可执行文件，我们要编译和链接输入文件 main.o 和 libvector.a：
>
> ```bash
> gcc -c main2.c
> gcc -static -o prog2c main2.o /libvector.a
> # 或者等价地使用：
> gcc -static -o prog2c main2.o -L. -lvector
> ```
>
> *在新版本的 linux 系统下安装 glibc-devel、glibc 和 gcc-c++ 时，都不会安装 libc.a，只安装 libc.so。所以当使用 `-static` 时，libc.a 库不能使用。*
>
> ```bash
> yum install glibc-static
> ```
>
> `-static` 参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无须更进一步的链接。`-lvector` 参数是 libvector.a 的缩写，`-L.` 参数高速链接器在当前目录下查找 libvector.a。

#### 7.6.3 链接器如何使用静态库来解析引用

> 虽然静态库很有用，但是它们同时也是一个程序员迷惑的源头，原因在于 Linux 链接器使用它们解析外部引用的方式。在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。（驱动程序自动将命令行中所有的 .c 文件翻译为 .o 文件。）在这次扫描中，连接器维护一个可重定位目标文件的集合 E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了但是尚未定义的符号）集合 U，以及一个在前面输入文件中已定义的符号集合 D。初始时，E、U 和 D 均为空。
>
> - 对于命令行上的每个输入文件 f，链接器会判断 f 是一个目标文件还是一个存档文件。如果 f 是一个目标文件，那么链接器把 f 添加到 E，修改 U 和 D 来反映 f 中的符号定义和引用，并继续下一个输入文件。
> - 如果 f 是一个存档文件，那么链接器就尝试匹配 U 中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员 m，定义了一个符号来解析 U 中的一个引用，那么就将 m 加到 E 中，并且链接器修改 U 和 D 来反映 m 中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到 U 和 D 都不再发生变化。此时，如何不包含在 E 中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。
> - 如果当链接器完成对命令上输入文件的扫描后，U 是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位 E 中地目标文件，构建输出的可执行文件。
>
> 不幸的是，这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，链接会失败。
>
> 关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的（也就是说没有成员引用另一个成员定义的符号），那么这些库就可以以任何顺序放置在命令行的结尾处。另一方面，如果库不是相互相互独立的，那么必须对它们排序，使得对于每个被存档文件的成员外部引用的符号 s，在命令行中至少有一个 s 的定义是在对 s 的引用之后的。
>
> 如果需要满足依赖需求，可以在命令行上重复库。

*注意步骤的第二步，编译器只会保留有用的成员目标文件，没有用到的会被丢弃，才会产生后方引用的无法匹配到相应的定义的情况；如果是目标文件，会全部加入 U 和 D 中，顺序没有那么重要，放在库前即可；*

### 7.7 重定位

> 一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成：
>
> - 重定位节和符号定义
>
>   在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的 .data 节被全部合并成一节，这个节成为输出的可执行目标文件的 .data 节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。
>
>   *虽然全局变量有了运行时内存地址，但是代码中对全局变量的引用仍然是符号；*
>
> - 重定位节中的符号引用
>
>   在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目（relocation entry）的数据结构。

#### 7.7.1 重定位条目

> 当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在 .rel .text 中。已初始化数据的重定位条目放在 .rel .data 中。
>
> ELF 定义了 32 中不同的重定位类型，其中两种最基本的重定位类型：
>
> - R_X86_64_PC32
>
>   重定位一个使用 32 位 PC 相对地址的引用。一个 PC 相对地址就是距离程序计数器（PC）的当前运行时值得偏移量。当 CPU 执行一条使用 PC 相对寻址的指令时，它就将指令中编码的 32 位值加上 PC 的当前运行时值，得到有效地址（如 call 指令的目标），PC 值通常是下一条指令在内存中的地址。
>
> - R_X86_64_32
>
>   重定位一个使用 32 位绝对地址的引用。通过绝对寻址，CPU 直接使用在指令中编码的 32 位值作为有效地址，不需要进一步修改。
>
> 这两种重定位类型支持 x86-64 小型代码模型（small code model），该模型假设可执行目标文件中的代码和数据的总体大小小于 2GB，因此在运行时可以用 32 位 PC 相对地址来访问。GCC 默认使用小型代码模型。大于 2GB 的程序可以用 -mcmodel=medium（中型代码模型）和 -mcmodel=large（大型代码模型）标志来编译。

#### 7.7.2 重定位符号引用

ELF 重定位条目的格式：

```c
typedef struct {
    long offset;	/* Offset of the reference to relocate */
    long type:32,   /* Relocation type */
        symbol: 32; /* Symbol table index */
    long addend;    /* Constant part of relocation expression */
} Elf64_Rela;
```

对一下代码产生可重定向目标文件 main.o：

```c
int sum(int *a, int n);

int array[2] = {1, 2};

int main()
{
    int val = sum(array, 2);
    return val;
}
```

使用 objdump 解析可重定向目标文件，这里 `-d` 显示可执行部分的汇编程序内容：

```bash
gcc -d main.o
```

得到

```assembly
0000000000000000 <main>:
   0:	48 83 ec 08          	sub    $0x8,%rsp
   4:	be 02 00 00 00       	mov    $0x2,%esi
   9:	bf 00 00 00 00       	mov    $0x0,%edi
   e:	e8 00 00 00 00       	callq  13 <main+0x13>
  13:	48 83 c4 08          	add    $0x8,%rsp
  17:	c3                   	retq
```

使用标志 `-r` 显示文件中的重定位条目：

```bash
gcc -r main.o
```

```
main.o:     file format elf64-x86-64

RELOCATION RECORDS FOR [.text]:
OFFSET           TYPE              VALUE 
000000000000000a R_X86_64_32       array
000000000000000f R_X86_64_PC32     sum-0x0000000000000004
```

可以看到 `array` 的偏移量（在 `.text` ）中为 0x0a，而 0x0a 的命令为：

```assembly
   9:	bf 00 00 00 00       	mov    $0x0,%edi
```

这句命令即在为调用 `sum` 函数将参数放入寄存器中，因为不知道全局变量 `array` 的地址信息，使用了占位符；其次重定位条目中 `array` 的类型为 `R_X86_64_32`（使用 32 位绝对地址的引用）也就是为什么使用了 4 字节占位符的原因；

`sum` 同理，但是类型为 `R_X86_64_PC32`（使用 32 位 PC 相对地址的引用），需要计算出地址差；

ELF 重定位条目的格式中，

> addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。

书中例子 `addend` 值为 -4，这是因为执行该指令时，PC 已经指向了下一条指令，需要减 4 修正。
$$
PC + OFFSET_{ADDR} = SUM_{ADDR}
$$

$$
OFFSET_{ADDR} = SUM_{ADDR} - PC = SUM_{ADDR} - (SYMBOL_{SUM} + 4)
$$

### 7.8 可执行目标文件

> 示例 C 程序，开始时是一组 ASCII 文本文件，现在已经被转化为一个二进制文件，且这个二进制文件包含加载程序到内存并运行它所需的所有信息。一个典型的 ELF 可执行文件中的各类信息*（内存地址从低到高）*：
>
> - 只读内存段（代码段）
>   - ELF 头
>   - 段头部表（将连续的文件节映射到运行时内存段）
>   - .init
>   - .text
>   - .rodata
> - 读/写内存段（数据段）
>   - .data
>   - .biss
> - 不加载到内存的符号表和调试信息
>   - .symtab
>   - .debug
>   - .line
>   - .strtab
>   - 节头部表（描述目标文件的节）
>
> 可执行目标文件的格式类似于可重定位目标文件的格式。ELF 头描述文件的总体格式。它还包括程序的入口点（entry point），也就是当程序运行时要执行的第一条指令的地址。.text、.rodata 和 .data 节与可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。.init 节定义了一个小函数，叫做 _init，程序的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位），所以它不再需要 .rel 节。
>
> ELF 可执行文件被设计得很容易加载到内存，可执行文件得连续的片（chunk）被映射到连续的内存段。程序头部表（program header table）描述了这种映射关系。
>
> 可执行文件 prog 的程序头部表（地址截断一半为 4 字节）：
>
> ```
> Read-only code segment
> LOAD off    0x00000000 vaddr 0x00400000 paddr 0x00000000 align 2**21
>      filesz 0x0000069c memsz 0x0000069c flags r-x
> 
> Read/write data segment
> LOAD off    0x00000df8 vaddr 0x00600df8 paddr 0x00600df8 align 2**21
>      filesz 0x00000228 memsz 0x00000230 flags rw-
> ```
>
> off：目标文件中的偏移；vaddr/paddr 内存地址；align：对齐要求；fizesz：目标文件中的段大小；memsz：内存中的段大小；flags：运行时访问权限。
>
> 从程序头部表，我们会看到根据可执行目标文件的内容初始化两个内存段。第 1 行和第 2 行告诉我们第一个段（代码段）有读/执行访问权限，开始于内存地址 0x400000 处，总共的内存大小是 0x69c 字节，并且被初始化为可执行目标文件的头 0x69c 个字节，其中包括 ELF 头、程序头部表以及 .init、.text 和 .rodata 节。
>
> 第 3 行和第 4 行告诉我们第二个段（数据段）有读/写访问权限，开始于内存地址 0x600df8 处，总的内存大小为 0x230 字节，并用从目标文件中偏移 0xdf8 处开始的 .data 节中的 0x228 个字节初始化。该段中剩下的 8 个字节对应运行时将被初始化为 0 的 .bss 数据。
>
> 对于任何段 s，链接器必须选择一个起始地址 vaddr，使得
> $$
> vaddr\ mod\ align = off\ mod\ align
> $$
> 这里，off 是目标文件中段的第一个节的偏移量，align 是程序头部中指定的对齐（2^21 = 0x200000）。例如，上方的数据段中
> $$
> vaddr\ mod\ align = 0x600df8\ mod\ 0x200000 = 0xdf8
> $$
> 以及
> $$
> off\ mod\ align = 0xdf8\ mod 0x200000 = 0xdf8
> $$
> 这个对齐要求是一种优化，使得当程序执行时，目标文件中的段能够很有效率地传送到内存中。原因有点儿微妙，在于虚拟内存的组织方式，它被组织成一些很大的、连续的、大小为 2 的幂的字节片。第 9 张会学习到虚拟内存的知识。

### 7.9 加载可执行目标文件

> shell 通过调用某个驻留在存储器中称为加载器（loader）的操作系统代码来运行可执行目标文件。任何 Linux 程序都可以通过调用 execve 函数来调用加载器（8.4.6 节中详细描述）。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。
>
> 每个 Linux 程序都有一个运行时内存映像，类似于（内存地址从高到低）：
>
> - 内核内存（对用户代码不可见的内存）
>
> - 用户栈（运行时创建）<- %rsp（栈指针）
>
>   向内存地址低位延伸；
>
> - 共享库的内存映射区域
>
>   图中看，向内存地址高位延伸；
>
> - 运行时堆（由 malloc 创建）<- brk
>
> - 读/写段（.data，.bss）（从可执行文件中加载）
>
> - 只读代码段（.init，.text，.rodata）（从可执行文件中加载）@0x400000
>
> 在 Linux x86-64 系统中，代码段总是从地址 0x400000 处开始，后面是数据段。运行时堆在数据段之后，通过调用 malloc 库往上增长。（9.9 节中详细描述 malloc 和堆。）堆后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址*（原书勘误，不是 2^48-1，更小且每个进程不同。）*开始，向较小内存地址增长。栈上的区域，是为内核（kernel）中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分。
>
> 为了简洁，我们把堆、数据和代码段画得彼此相邻，并且把栈顶放在了最大的合法用户地址处。实际上，由于 .data 段有对齐要求，所以代码段和数据段之间是有间隙的。同时，在分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间布局随机化（ASLR）。**虽然每次程序运行时这些区域的地址都会改变，它们的相对位置是不变的。**

