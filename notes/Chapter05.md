## Chapter 5

> 程序优化的第一步是消除不必要的工作，让代码尽可能有效地执行所期望地任务。这包括消除不必要地函数调用、条件测试和内存引用。这些优化不依赖于目标机器地任何具体属性。
>
> 了解了处理器地运作，我们就可以进行程序优化地第二步，利用处理器提供地指令级并行（instruction-level parallelism）能力，同时执行多条指令。
>
> 即时是最好地编译器也受到妨碍优化地因素（optimization blocker）的阻碍，妨碍优化的因素就是程序行为中那些严重依赖于执行环境的方面。
>
> 正如我们会看到的，常常通过确认关键路径（critical path）来决定执行一个循环所需要地时间（或者说，至少是一个时间下界）。所谓关键路径是在循环地反复执行过程中形成地数据相关链。

### 5.1 优化编译器地能力和局限性 

> 我们会发现可以写出的 C 代码，即使用 `-O` 选项编译得到的性能，也比用可能的最高的优化等级编译一个更原始的版本的到的性能好。
>
> 这种两个指针可能指向同一个内存位置地情况称为内存别名使用（memory aliasing）。
>
> 包含函数调用的代码可以用一个称为内联函数替换（inline substitution，或者简称“内联（inlining）“）的过程进行优化，此时，将函数调用替换为函数体。
>
> 用内联函数替换优化函数调用
>
> GCC 的最近版本会尝试进行这种形式的优化，要么是被命令行选项“-finline”指示时，要么使用优化等级 `-O1` 或者更高的等级时。遗憾的是，GCC 只尝试在单个文件中定义的函数的内联。这就意味着它将无法应用于常见的情况，即一组库函数在一个文件中被定义，却被其他文件内的函数所调用。
>
> 在某些情况下，最好能阻止编译器执行内联替换。如果一个函数调用已经用内联替换优化过了，那么任何对这个调用进行追踪或设置断点的尝试都会失败。还有一种情况是用代码剖析的方式来评估程序性能。用内联替换消除的函数调用是无法被正确剖析的。

实测需要使用 `-O2` 会优化成内联函数。

### 5.2 表示程序性能

> 我们引入度量标准每元素的周期数（Cycles Per Element，CPE），作为一种表示程序性能并指导我们改进代码的方法。
>
> 处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用千兆赫兹（GHz），即十亿周期每秒来表示。例如，当表明一个系统有“4GHz”处理器，这表示处理器时钟运行频率为每秒 4*10^9 个周期。每个时钟周期的时间是时钟频率的倒数。通常是以纳秒（nanosecond，1 纳秒等于 10^-9 秒）或皮秒（picosecond，1 皮秒等于 10^-12 秒）为单位的。从程序员的角度来看，用时钟周期来表示度量标准要比用纳秒或皮秒来表示有帮助得多。用时钟周期来表示，度量值表示的是执行了多少条指令，而不是时钟运行得有多快。
>
> 这些项中的系数称为每元素的周期数（简称 CPE）的有效值。注意，我们更愿意用每个元素的周期数而不是每次循环的周期数来度量，这是因为像循环展开这样的技术使得我们能够用较少的循环完成计算，而我们最终关心的是，对于给定的向量长度，程序运行的速度如何。我们将精力集中在减小计算的 CPE 上。
>
> 什么是最小二乘拟合
>
> 对于一个数据点（x~1~，y~1~），...，（x~n~，y~n~）的集合，我们常常试图画一条线，它能最接近于这些数据代表的 X-Y 趋势。使用最小二乘拟合，寻找一条形如 y=mx+b 的线，使得下面这个误差度量最小：
> $$
> E(m,b)=\sum\limits_{i=1,n}(mx_i+b-y_i)^2
> $$
> 将 E（m，b） 分别对 m 和 b 求导，把两个导数函数设置为 0，进行推导就能得出计算 m 和 b 的算法。

### 5.4 消除循环的低效率

> 这个优化是一类常见的优化的一个例子，称为代码移动（code motion）。这类优化包括识别要执行多次（例如在循环里）但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。

### 5.5 减少过程调用

> 像我们看到过的那样，过程调用会带来开销，而且妨碍大多数形式的程序优化。

### 5.6 消除不必要的内存引用

> 我们可以开电脑每次迭代时，累计变量的数值都要从内存读出再写入到内存。这样的读写很浪费；

### 5.7 理解现代处理器

> 为了理解改进性能的方法，我们需要理解现代处理器的微体系结构。在代码级上，看上去似乎是一次执行一条指令，每条指令都包括从寄存器或内存取值，执行一个操作，并把结果存回到一个寄存器或内存位置。在实际的处理器中，是同时对多条指令求值的，这个现象称为指令级并行。现代微处理器取得的了不起的功绩之一是：它们采用复杂而奇异的微处理器结构，其中，多条指令可以并行地执行，同时又呈现出一种简单的顺序执行指令的表象。
>
> 我们会发现两种下界描述了程序的最大性能。当一系列操作必须按照严格顺序执行时，就会遇到延迟界限（latency bound），因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制程序性能。吞吐量界限（throughput bound）刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。

#### 5.7.1 整体操作

> 整个设计有两个主要部分：指令控制单元（Instruction Control Unit，ICU）和执行单元（Execution Unit，EU）。前者负责从内存中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作；而后者执行这些操作。
>
> ICU 从指令高速缓存（instruction cache）中读取指令，指令高速缓存是一个特殊的高速储存器，它包含最近访问的指令。
>
> 指令译码逻辑接收实际的程序指令，并将它们转换成一组基本操作（有时称为微操作）。
>
> 在 ICU 中，退役单元（retirement unit）记录正在进行的处理，并确保它遵守机器级程序的顺序语义。我们的图中展示了一个寄存器文件，它包含整数、浮点数和最近的 SSE 和 AVX 寄存器，是退役单元的一部分，因为退役单元控制这些寄存器的更新。指令译码时，关于指令的信息被放置在一个先进先出的队列中。这些信息会一直保持在队列中，直到发生以下两个结果中的一个。首先，一旦一条指令的操作完成了，而且所有引起这条指令的分支点也都被确认为预测正确，那么这条指令就可以退役（retired）了，所有对程序寄存器的更新都可以被实际执行了。另一方面，如果引起该指令的某个分支点预测错误，这条指令会被清空（flushed），丢弃所有计算出来的结果。通过这种方法，预测错误就不会改变程序的状态了。
>
> 控制操作数在执行单元间传送的最常见的机制称为寄存器重命名（register renaming）。

#### 5.7.2 功能单元的性能

> 每个运算都是由以下的这些数值来刻画的：一个是延迟（latency），它表示完成运算所需要的总时间；另一个是发射时间（issue time），它表示两个连续的同类型的运算之间需要的最小时钟周期数；还有一个是容量（capacity），它表示能够执行该运算的功能单元的数量。
>
> 一个典型的浮点加法器包含三个阶段（所以有三个周期的延迟）：一个阶段处理指数值，一个阶段将小数相加，而另一个阶段对结果进行摄入。发射时间为 1 的功能单元被称为完全流水线化（fully pipelined）：每个时钟周期可以开始一个新的运算。
>
> 表达发射时间的一种更常见的方法是指明这个功能单元的最大吞吐量，定义为发射时间的倒数。具有多个功能单元可以进一步提高吞吐量。对一个容量为 C，发射时间为 I 的操作来说，处理器可能获得的吞吐量为每时钟周期 C/I 个操作。

