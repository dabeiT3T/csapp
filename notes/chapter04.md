## Chapter 4

> 一个处理器支持的指令和指令的字节编码称为它的指令集体系结构（Instruction-Set Architecture, ISA）。
>
> 在计算机科学中，用巧妙的方法在提高性能的同时又保持一个更简单、更抽象模型的功能，这种思想是众所周知的。在 Web 浏览器或者平衡二叉树和哈希表这样的信息检索数据结构中使用缓存，就是这样的例子。
>
> 我们还将介绍一种描述硬件系统控制部分的简单语言，HCL（Hardware Control Language，硬件控制语言）。

### 4.1 Y86-64 指令集体系结构

#### 4.1.3 指令编码

> 程序寄存器存在 CPU 中的一个寄存器文件中，这个寄存器文件就是一个小的、以寄存器 ID 作为地址的随机访问存储器。
>
> x86-64 有时称为”复杂指令集计算机“（CISC），与“精简指令集计算机”（RISC）相对。

#### 4.1.4 Y86-64 异常

> 处理器通常会调用一个异常处理程序（exception handler），这个过程被指定用来处理遇到的某种类型的异常。就像在第 8 章中讲述的，异常处理程序可以被配置成不同的结果，例如，中止程序或调用一个用户自定义的信号处理程序（signal handler）。

#### 4.1.5 Y86-64 程序

> 伪指令（directive）指明应该将代码或数据放在什么位置，以及如何对齐。

与 GCC 标准不同，栈从地址 0x200 开始，第一个 `call` 命令应该把回调地址 0x13 放在0x200 位置才对；但此处，栈的使用导致内存地址 0x1f0~0x1f8 发生了变化。

#### 4.1.6 一些 Y86-64 指令地详情

`pushq` 指令会把栈指针减 8，并且将一个寄存器值写入内存中。

当执行

```assembly
pushq %rsp
```

指令时，x86-64 处理器会压入 `%rsp` 地原始值；

> The PUSH ESP instruction pushed the value of the ESP register as it existed before the instruction was executed. If a PUSH instruction uses a memory operand in which the ESP register is used for computing the operand address, the address of the operand is computed before the ESP register is decremented.

当执行

```assembly
popq %rsp
```

指令时，x86-64 处理器会将栈指针设置为从内存中读出来地那个值；

> The POP ESP instruction increments the stack pointer (ESP) before data at the old top of stack is written into the destination.[^1]

### 4.2 逻辑设计和硬件控制语言 HCL

> 要实现一个数字系统需要三个主要地组成部分：计算对位进行操作地函数地组合逻辑、存储位地存储器单元，以及控制存储器单元更新地时钟信号。
>
> 现在，大多数电路设计都是用硬件描述语言（Hardware Description Language，HDL）来表达地。HDL 是一种文本表示，看上去和编程语言类似，但是它是用来描述硬件结构而不是程序行为的。最常用地语言是 Verilog，它地语法类似于 C；另一种是 VHDL，它地语法类似于编程语言 Ada。

#### 4.2.3 字级的组合电路和 HCL 整数表达式

> 在 HCL 中，多路复用函数是用情况表达式（case expression）来描述的。我们不要求不同的表达式之间互斥。从逻辑上讲，这些选择表达式是顺序求值的，且第一个求值为 1 的情况会被选中。允许不互斥的选择表达式使得 HCL 代码的可读性更好。实际的硬件多路复用器的信号必须互斥，它们要控制哪个输入字应该被传送到输出。

就像练习题 4.12 的答案一样，表达式可以将“或”的条件放在两行，就像没有 break 的 switch 一样的。

```verilog
word Med3 = [
    A <= B && B <= C : B;
    C <= B && B <= A : B;
    B <= A && A <= C : A;
    C <= A && A <= B : A;
    1                : C;
]
```

#### 4.2.5 存储器和时钟

> 存储设备都是由同一个时钟控制的，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两类存储器设备：
>
> - 时钟寄存器（简称寄存器）存储单个位或字。时钟信号控制寄存器加载输入值。
> - 随机访问存储器（简称内存）存储多个字，用地址来选择该读或该写哪个字。随机访问存储器的例子包括：1）处理器的虚拟内存系统，硬件和操作系统软件结合起来使处理器可以在一个很大的地址空间内访问任意的字；2）寄存器文件，在此，寄存器标识符作为地址。
>
> 一个很自然的问题就是“如果我们试图同时读和写同一个寄存器会发生什么？”答案简单明了：如果更新一个寄存器，同时在读端口上用同一个寄存器 ID，我们会看到一个从旧值到新值的变化。

### 4.3 Y86-64 的顺序实现

#### 4.3.1 将处理组织成阶段

> 下面是关于各个阶段以及各阶段内执行操作的简略描述：
>
> - 取指（fetch）：取指阶段从内存读取指令字节，地址为程序计数器（PC）的值。从指令中抽取出指令指示符字节的两个四位部分，称为 icode（指令代码）和 ifun（指令功能）。它可能取出一个寄存器指示符字节，指明了一个或两个寄存器操作数指示符 rA 和 rB。它还可能取出一个四字节常数字 `valC`。它按顺序方式计算当前指令的下一条指令的地址 `valP`。也就是说，valP 等于 PC 的值加上已取出指令的长度。
> - 译码（decode）：译码阶段从寄存器文件读入最多两个操作数，得到值 `valA` 和/或 `valB`。通常，它读入指令 rA 和 rB字段指明的寄存器，不过有些指令是读寄存器 %rsp 的。
> - 执行（execute）：在执行阶段，算术/逻辑单元（ALU）要么执行指令指明的操作（根据 ifun 的值），计算内存引用的有效地址，要么增加或减少栈指针。得到的值我们称为 `valE`。在此，也可能设置条件码。对一条条件传送指令来说，这个阶段会检验条件码和传送条件（由 ifun 给出），如果条件成立，则更新目标寄存器。同样，对一条跳转指令来说，这个阶段会决定是不是应该选择分支。
> - 访存（memory）：访存阶段可以将数据写入内存，或者从内存读出数据。读出的值为 `valM`。
> - 写回（write back）：写回阶段最多可以写两个结果到寄存器文件。
> - 更新 PC（PC update）：将 PC 设置成下一条指令的地址。

`rrmovq`、`irmovq` 指令在执行阶段基本都执行了将数据与 0 相加的操作，~~可能是为了与 `OPq` 指令保持一致，在写回阶段使用 valE 地值~~；

#### 4.3.2 SEQ 硬件结构

以 SEQ 的硬件结构为例：

- ALU 的输入端口 A 由 `valC` 或者寄存器 `valA` 作为输入；
- ALU 的输入端口 B 由 `valB` 作为输入；
- 数据内存的地址端口由 `valE` 或者 `valA` 作为输入；
- 数据内存的数据端口由 `valP` 或者 `valA` 作为输入；
- 寄存器文件数据端口 A 可以作为 ALU A 的输入或者数据内存的地址和数据端口的输入；`rmmoveq`、`pushq`、`popq`、`ret` 指令中，`valA` 可以直接输入数据内存中；
- 寄存器文件数据端口 B 只可以作为 ALU B 的输入；
- 寄存器文件数据端口 E 由 `valE` 作为输入，所以 `rrmovq` 和 `irmovq` 的数据 `valA` 和 `valC` 不能直接作为寄存器文件的输入，得通过 ALU 输出 `valE` 传入到寄存器文件端口 E 中；
- 寄存器文件地址端口 dstE 由 `rB` 作为输入，也就是计算出来 `valE` 的会存于地址 `rB`；
- 寄存器文件数据端口 M 由 `valM` 作为输入，所以一次寄存器文件可以满足修改两个寄存器的值；
- 寄存器文件地址端口 dstM 由 `rA` 作为输入，也就是访存得到的 `valM` 的会存于地址 `rA`；
- 新 PC 由 `valC`、`valM` 和 `valP` 作为输入；

#### 4.3.3 SEQ 的时序

以文中 Y86-64 模型为例：

> 原则：从不回读
>
> 处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态。

- 程序计数器 PC 保持输出 64 位高低电压（表示一个地址）；

- 指令内存以 PC 作为输入，并在短暂延时（远远小于一个时钟周期）后，保持输出对应的高低电压；

  寄存器文件的读、算术逻辑单元都是一个逻辑组合；

- 如果有整数运算，算术逻辑单元会修改对条件码的输出电压，但条件码是一个时钟寄存器，条件码在下一个时钟上升沿前都保持原有的输出电压；

- 数据内存、寄存器文件的写、程序计数器 PC 都是时钟寄存器，计算完成后，它们的输入电压产生相应的改变，等待下一个时钟上升沿就将数据写入；

- 一个周期结束，时钟上升沿；

- 程序计数器 PC 和条件码的输出更新为其输入，整个组合逻辑的电压都会在短暂延时后产生相应的新变化（新轮回）；数据将写入数据内存和寄存器文件；



[^1]:<Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2: Instruction Set Reference, A-Z>

