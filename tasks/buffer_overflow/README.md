## Buffer Overflow Attack
针对章节 `3.10.4` 的对抗缓冲区溢出攻击的三种方案进行验证。

测试的虚拟机如下：

```bash
#Linux 3.10.0-1160.42.2.el7.x86_64
#gcc version 4.8.5 20150623 (Red Hat 4.8.5.-44) (GCC)
```

代码 `main.0.c` 即书上列举的存在缓冲区溢出的代码，后面的例子都借助于该框架；不过使用直接赋值，而不是从外部读取数据；

我们通过

```bash
gcc main.0.c -o main.0 # 默认优化编译
objdump -d main.0 >> main.0.disassemble # 获得反编译文件
```

获得了反编译的文件（剔除了不重要的部分）。

### 栈随机化

> 在 Linux 系统中，栈随机化已经变成了标准行为。它是更大的一类技术中的一种，这类技术称为地址空间布局随机化（Address-Space Layout Randomization），或者简称 ASLR。采用 ASLR，每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据，都会被加载到内存的不同区域。

代码 `main.1.c` 即书中确定“典型的”栈地址的方法；编译执行后，每次打印的变量地址的确是不一样的；**栈地址在每次运行时，是不相同的。**

查看代码 `main.0.disassemble`，每行命令都有一个地址；第 53 行

```
400608:	e8 85 ff ff ff       	callq  400592 <mgets>
```

调用函数 `mgets` 使用的是相对地址偏移量的方式；

为了验证命令代码在虚拟内存中是固定地址，我们可以将回调地址打印出来；

```
00000000004005f9 <echo>:
  4005f9:	55                   	push   %rbp
  4005fa:	48 89 e5             	mov    %rsp,%rbp
  4005fd:	48 83 ec 10          	sub    $0x10,%rsp
  400601:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  400605:	48 89 c7             	mov    %rax,%rdi
  400608:	e8 85 ff ff ff       	callq  400592 <mgets>
```

当 `%rip` 指向函数 `echo` 起始地址时，栈顶为回调地址；

命令 `push` 将栈顶 -8，`sub` 将栈顶 -16 用来存储变量 `buf`，所以此时回调地址位于变量 `buf` - 24 个字节偏移量的地址；

代码 `main.2.c` 将打印出回调地址；因为修改了代码，命令的地址有所改动，但是他是一个固定的地址；所以，**命令地址在每次运行时，是相同的。**

由于函数地址是固定的，自然而然会想到如果在回调地址处，塞一个函数地址，就会跳转到我们指定的地址了；代码 `main.3.c` 将回调地址修改为全局没有调用过的函数 `hack`；编译执行后，的确成功调用了 `hack` 函数；不过由于栈被破坏，程序执行完 `hack` 函数后，没有办法找到有效的回调地址，程序崩溃了；

### 栈破坏检测

> 它只会带来很小的性能损失，特别是因为 GCC 只在函数中有局部 char 类型缓冲区的时候才插入这样的代码。

查看代码 `main.0.disassemble`，在默认优化编译下**并没有看到 GCC 插入了金丝雀检查代码**；

### 限制可执行代码区域

思路

- 将 `buf` 的起始地址塞入回调地址处；
- CPU 跳转执行 `buf` 中存二进制机器代码；为了直观得看出结果，二进制机器码跳转到函数 `hack`，打印语句；

*不同于 GCC 一般使用的短跳转，通过相对地址偏移量算出来；此处的无条件跳转，我们希望是一个 64 位的绝对地址；查阅资料，此处跳转地址需要存放在一个寄存器中；*

代码 `main.4.c` 中将污染的缓冲区都打印了出来；可以看到的确赋值了目标可执行二进制代码；

代码编译执行失败了；通过 `gdb` 调试，可以看到当计数器指向栈时显示

```
No function contains program counter for selected frame.
```

**栈中可执行二进制通过回调地址跳转并不能执行。**

肯定还有更多的攻击方法，需要继续学习：）

